#ifndef AST_H
#define AST_H

/* MELP Stage 2 - Abstract Syntax Tree Definitions
 * Generated by: YZ_03 (Parser Specialist)
 * Date: 16 Ocak 2026
 * Phase: 3.0 - Parser Implementation (Task 3.1)
 * 
 * This header defines all AST node types for PMLP0/PMLP1 syntax.
 * 
 * Design Principles:
 * - Clear node hierarchy (program → functions → statements → expressions)
 * - Union-based variant design for memory efficiency
 * - Complete source location tracking (line, column)
 * - Explicit memory management (create/free functions)
 */

#include "token.h"

/* ============================================================================
 * AST NODE TYPES
 * ============================================================================ */

/* AST Node Type Classification
 * 
 * Categories:
 * - Program Structure: PROGRAM, FUNCTION
 * - Statements: RETURN, VAR_DECL, ASSIGNMENT, IF, WHILE, EXPR_STMT
 * - Expressions: BINARY_OP, UNARY_OP, LITERAL, IDENTIFIER, FUNCTION_CALL
 * - Types: TYPE
 * - Parameters: PARAMETER
 */
typedef enum {
    /* Program Structure */
    AST_PROGRAM,              /* Root node (list of functions) */
    AST_FUNCTION,             /* Function declaration */
    
    /* Statements */
    AST_RETURN,               /* return expression */
    AST_VAR_DECL,             /* numeric x = expr (with type) */
    AST_ASSIGNMENT,           /* x = expr (without type) */
    AST_IF,                   /* if-then-else-end_if */
    AST_WHILE,                /* while-end_while */
    AST_EXPR_STMT,            /* Expression statement (function call) */
    
    /* Expressions */
    AST_BINARY_OP,            /* x + y, a == b, a and b, etc. */
    AST_UNARY_OP,             /* not x, -x */
    AST_LITERAL,              /* 42, true, false */
    AST_IDENTIFIER,           /* variable reference */
    AST_FUNCTION_CALL,        /* func(arg1; arg2; arg3) */
    
    /* Types */
    AST_TYPE,                 /* numeric, boolean */
    
    /* Parameters & Arguments */
    AST_PARAMETER             /* name as type (in function declaration) */
} ASTNodeType;

/* Forward declaration for self-referential structure */
typedef struct ASTNode ASTNode;

/* ============================================================================
 * AST NODE STRUCTURE
 * ============================================================================ */

/* AST Node - Variant/Union Design
 * 
 * All AST nodes share:
 * - type: Node classification
 * - line, column: Source location (for error reporting)
 * - data union: Type-specific fields
 * 
 * Memory Management:
 * - All nodes allocated via create_*_node() functions
 * - All nodes freed via free_ast() recursive traversal
 * - String pointers (names, etc.) are NOT copied (point to token lexemes)
 * - Child nodes are owned (freed recursively)
 */
struct ASTNode {
    ASTNodeType type;
    int line;                 /* Source line (1-based) */
    int column;               /* Source column (1-based) */
    
    union {
        /* AST_PROGRAM
         * Root node containing all top-level function declarations.
         */
        struct {
            ASTNode** functions;      /* Array of AST_FUNCTION nodes */
            int function_count;
        } program;
        
        /* AST_FUNCTION
         * Function declaration with parameters and body.
         * 
         * Example: function add(numeric a; numeric b) as numeric
         *            return a + b
         *          end_function
         */
        struct {
            const char* name;         /* Function name (points to token) */
            ASTNode** parameters;     /* Array of AST_PARAMETER nodes */
            int parameter_count;
            ASTNode* return_type;     /* AST_TYPE node (numeric, boolean) */
            ASTNode** body;           /* Array of statement nodes */
            int body_count;
        } function;
        
        /* AST_RETURN
         * Return statement with optional expression.
         * 
         * Example: return x + 42
         */
        struct {
            ASTNode* expression;      /* Return value (can be NULL for void) */
        } return_stmt;
        
        /* AST_VAR_DECL
         * Variable declaration with type and optional initializer.
         * 
         * Example: numeric x = 42
         *          boolean flag
         */
        struct {
            const char* name;         /* Variable name (points to token) */
            ASTNode* type;            /* AST_TYPE node */
            ASTNode* initializer;     /* Expression (can be NULL) */
        } var_decl;
        
        /* AST_ASSIGNMENT
         * Variable assignment (without type).
         * 
         * Example: x = 100
         */
        struct {
            const char* name;         /* Variable name (points to token) */
            ASTNode* value;           /* Expression */
        } assignment;
        
        /* AST_IF
         * If-then-else statement.
         * 
         * Example: if x > 0 then
         *            print(x)
         *          else
         *            print(0)
         *          end_if
         */
        struct {
            ASTNode* condition;       /* Boolean expression */
            ASTNode** then_body;      /* Array of statements */
            int then_count;
            ASTNode** else_body;      /* Array of statements (can be NULL) */
            int else_count;
        } if_stmt;
        
        /* AST_WHILE
         * While loop statement.
         * 
         * Example: while i < 10
         *            i = i + 1
         *          end_while
         */
        struct {
            ASTNode* condition;       /* Boolean expression */
            ASTNode** body;           /* Array of statements */
            int body_count;
        } while_stmt;
        
        /* AST_BINARY_OP
         * Binary operation (arithmetic, comparison, logical).
         * 
         * Example: x + y, a == b, p and q
         */
        struct {
            TokenType op;             /* Operator type (+, -, *, ==, and, etc.) */
            ASTNode* left;            /* Left operand */
            ASTNode* right;           /* Right operand */
        } binary_op;
        
        /* AST_UNARY_OP
         * Unary operation (logical not, negation).
         * 
         * Example: not flag, -x
         */
        struct {
            TokenType op;             /* Operator type (not, -) */
            ASTNode* operand;         /* Operand */
        } unary_op;
        
        /* AST_LITERAL
         * Literal value (number, boolean).
         * 
         * Example: 42, true, false
         */
        struct {
            TokenType literal_type;   /* TOKEN_NUMBER, TOKEN_TRUE, TOKEN_FALSE */
            union {
                long long int_value;  /* For TOKEN_NUMBER */
            } value;
        } literal;
        
        /* AST_IDENTIFIER
         * Variable reference.
         * 
         * Example: x, result, my_var
         */
        struct {
            const char* name;         /* Variable name (points to token) */
        } identifier;
        
        /* AST_FUNCTION_CALL
         * Function call with arguments.
         * 
         * Example: print(x), add(1; 2; 3)
         */
        struct {
            const char* name;         /* Function name (points to token) */
            ASTNode** arguments;      /* Array of expression nodes */
            int argument_count;
        } call;
        
        /* AST_TYPE
         * Type specifier.
         * 
         * Example: numeric, boolean
         */
        struct {
            TokenType type_token;     /* TOKEN_NUMERIC, TOKEN_BOOLEAN */
        } type;
        
        /* AST_PARAMETER
         * Function parameter declaration.
         * 
         * Example: numeric x (in function declaration)
         */
        struct {
            const char* name;         /* Parameter name (points to token) */
            ASTNode* type;            /* AST_TYPE node */
        } parameter;
    } data;
};

/* ============================================================================
 * AST CONSTRUCTION FUNCTIONS
 * ============================================================================ */

/* Create program node (root) */
ASTNode* create_program_node(ASTNode** functions, int function_count, int line, int column);

/* Create function node */
ASTNode* create_function_node(const char* name, ASTNode** parameters, int param_count,
                               ASTNode* return_type, ASTNode** body, int body_count,
                               int line, int column);

/* Create statement nodes */
ASTNode* create_return_node(ASTNode* expression, int line, int column);
ASTNode* create_var_decl_node(const char* name, ASTNode* type, ASTNode* initializer,
                               int line, int column);
ASTNode* create_assignment_node(const char* name, ASTNode* value, int line, int column);
ASTNode* create_if_node(ASTNode* condition, ASTNode** then_body, int then_count,
                        ASTNode** else_body, int else_count, int line, int column);
ASTNode* create_while_node(ASTNode* condition, ASTNode** body, int body_count,
                           int line, int column);
ASTNode* create_expr_stmt_node(ASTNode* expression, int line, int column);

/* Create expression nodes */
ASTNode* create_binary_op_node(TokenType op, ASTNode* left, ASTNode* right,
                                int line, int column);
ASTNode* create_unary_op_node(TokenType op, ASTNode* operand, int line, int column);
ASTNode* create_literal_node(TokenType literal_type, long long int_value,
                              int line, int column);
ASTNode* create_identifier_node(const char* name, int line, int column);
ASTNode* create_call_node(const char* name, ASTNode** arguments, int arg_count,
                          int line, int column);

/* Create type and parameter nodes */
ASTNode* create_type_node(TokenType type_token, int line, int column);
ASTNode* create_parameter_node(const char* name, ASTNode* type, int line, int column);

/* ============================================================================
 * AST MEMORY MANAGEMENT
 * ============================================================================ */

/* Free AST tree recursively
 * 
 * Frees all nodes in the tree, including:
 * - Arrays of child nodes
 * - Dynamically allocated strings (if any were copied)
 * - The node itself
 * 
 * Safe to call with NULL node.
 */
void free_ast(ASTNode* node);

/* ============================================================================
 * AST UTILITY FUNCTIONS
 * ============================================================================ */

/* Get human-readable name for AST node type */
const char* ast_node_type_name(ASTNodeType type);

/* Print AST tree (for debugging) */
void print_ast(ASTNode* node, int indent);

#endif /* AST_H */
