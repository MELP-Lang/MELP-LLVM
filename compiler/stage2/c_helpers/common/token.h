#ifndef TOKEN_H
#define TOKEN_H

/* MELP Stage 2 - Token Definitions
 * Generated by: YZ_02 (Lexer Specialist)
 * Date: 15 Ocak 2026
 * Phase: 2.0 - Lexer Implementation (Task 2.1)
 * 
 * This header defines all token types for PMLP0 syntax.
 * Reference: STAGE2_SYNTAX_SPEC.md
 */

/* Token Types Enumeration
 * 
 * Categories:
 * - Literals (numbers, booleans, identifiers, strings)
 * - Keywords (language reserved words)
 * - Operators (arithmetic, comparison, logical)
 * - Delimiters (parentheses, brackets, punctuation)
 * - Special (newline, comment, EOF, error)
 */
typedef enum {
    /* === LITERALS === */
    TOKEN_NUMBER,           /* 42, 100, 999 (integer literals) */
    TOKEN_IDENTIFIER,       /* x, my_var, result (variable/function names) */
    TOKEN_TRUE,             /* true (boolean literal) */
    TOKEN_FALSE,            /* false (boolean literal) */
    TOKEN_STRING,           /* "text" (string literals - minimal support) */
    
    /* === KEYWORDS === */
    TOKEN_FUNCTION,         /* function */
    TOKEN_END_FUNCTION,     /* end_function */
    TOKEN_AS,               /* as (return type specifier) */
    TOKEN_RETURN,           /* return */
    TOKEN_IF,               /* if */
    TOKEN_THEN,             /* then */
    TOKEN_ELSE,             /* else */
    TOKEN_ELSE_IF,          /* else_if */
    TOKEN_END_IF,           /* end_if */
    TOKEN_WHILE,            /* while */
    TOKEN_END_WHILE,        /* end_while */
    TOKEN_VAR,              /* var (deprecated, use type directly) */
    TOKEN_NUMERIC,          /* numeric (type keyword) */
    TOKEN_BOOLEAN,          /* boolean (type keyword) */
    
    /* === OPERATORS - Arithmetic === */
    TOKEN_PLUS,             /* + (addition) */
    TOKEN_MINUS,            /* - (subtraction) */
    TOKEN_STAR,             /* * (multiplication) */
    TOKEN_SLASH,            /* / (division) */
    TOKEN_MOD,              /* mod (modulo) */
    
    /* === OPERATORS - Assignment === */
    TOKEN_EQUAL,            /* = (assignment) */
    
    /* === OPERATORS - Comparison === */
    TOKEN_EQUAL_EQUAL,      /* == (equality) */
    TOKEN_NOT_EQUAL,        /* != (inequality) */
    TOKEN_LESS,             /* < (less than) */
    TOKEN_LESS_EQUAL,       /* <= (less than or equal) */
    TOKEN_GREATER,          /* > (greater than) */
    TOKEN_GREATER_EQUAL,    /* >= (greater than or equal) */
    
    /* === OPERATORS - Logical === */
    TOKEN_AND,              /* and (logical AND) */
    TOKEN_OR,               /* or (logical OR) */
    TOKEN_NOT,              /* not (logical NOT) */
    
    /* === DELIMITERS === */
    TOKEN_LEFT_PAREN,       /* ( (left parenthesis) */
    TOKEN_RIGHT_PAREN,      /* ) (right parenthesis) */
    TOKEN_LEFT_BRACKET,     /* [ (left bracket - for future array support) */
    TOKEN_RIGHT_BRACKET,    /* ] (right bracket - for future array support) */
    TOKEN_SEMICOLON,        /* ; (parameter separator in function declaration) */
    TOKEN_COMMA,            /* , (future use - decimal separator alternative) */
    
    /* === SPECIAL === */
    TOKEN_NEWLINE,          /* \n (statement separator) */
    TOKEN_COMMENT,          /* -- (comment, typically skipped) */
    TOKEN_EOF,              /* End of file marker */
    TOKEN_ERROR             /* Lexer error (invalid character, etc.) */
} TokenType;

/* Token Structure
 * 
 * Represents a single lexical token with:
 * - Type classification
 * - Source text (lexeme)
 * - Position information (line, column)
 * - Optional parsed value
 * 
 * Memory Management:
 * - lexeme points to source string (no copy)
 * - str_value points to allocated string (for STRING, IDENTIFIER if needed)
 * - Caller responsible for freeing tokens via free_tokens()
 */
typedef struct {
    TokenType type;         /* Token classification */
    const char* lexeme;     /* Original text from source (NOT null-terminated substring!) */
    int lexeme_length;      /* Length of lexeme (since lexeme is NOT null-terminated) */
    int line;               /* Line number (1-based) */
    int column;             /* Column number (1-based) */
    
    /* Optional: Parsed value storage
     * 
     * For TOKEN_NUMBER: int_value contains the parsed integer
     * For TOKEN_STRING/TOKEN_IDENTIFIER: str_value contains the text
     * For TOKEN_TRUE/TOKEN_FALSE: Not needed (type is sufficient)
     */
    union {
        long long int_value;        /* For TOKEN_NUMBER */
        char* str_value;            /* For TOKEN_STRING, TOKEN_IDENTIFIER (allocated) */
    } value;
} Token;

/* Token Type String Names (for debugging/error messages)
 * 
 * Usage:
 *   const char* name = token_type_name(TOKEN_PLUS); // returns "+"
 * 
 * Returns a human-readable string representation of the token type.
 */
const char* token_type_name(TokenType type);

#endif /* TOKEN_H */
