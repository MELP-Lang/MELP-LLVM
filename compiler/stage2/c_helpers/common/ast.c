/* MELP Stage 2 - AST Node Implementation
 * Generated by: YZ_03 (Parser Specialist)
 * Date: 16 Ocak 2026
 * Phase: 3.0 - Parser Implementation (Task 3.1)
 * 
 * Implementation of AST node creation and management functions.
 */

#include "ast.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ============================================================================
 * AST NODE CREATION FUNCTIONS
 * ============================================================================ */

/* Create program node */
ASTNode* create_program_node(ASTNode** functions, int function_count, int line, int column) {
    ASTNode* node = malloc(sizeof(ASTNode));
    if (!node) return NULL;
    
    node->type = AST_PROGRAM;
    node->line = line;
    node->column = column;
    node->data.program.functions = functions;
    node->data.program.function_count = function_count;
    
    return node;
}

/* Create function node */
ASTNode* create_function_node(const char* name, ASTNode** parameters, int param_count,
                               ASTNode* return_type, ASTNode** body, int body_count,
                               int line, int column) {
    ASTNode* node = malloc(sizeof(ASTNode));
    if (!node) return NULL;
    
    node->type = AST_FUNCTION;
    node->line = line;
    node->column = column;
    node->data.function.name = name;
    node->data.function.parameters = parameters;
    node->data.function.parameter_count = param_count;
    node->data.function.return_type = return_type;
    node->data.function.body = body;
    node->data.function.body_count = body_count;
    
    return node;
}

/* Create return node */
ASTNode* create_return_node(ASTNode* expression, int line, int column) {
    ASTNode* node = malloc(sizeof(ASTNode));
    if (!node) return NULL;
    
    node->type = AST_RETURN;
    node->line = line;
    node->column = column;
    node->data.return_stmt.expression = expression;
    
    return node;
}

/* Create variable declaration node */
ASTNode* create_var_decl_node(const char* name, ASTNode* type, ASTNode* initializer,
                               int line, int column) {
    ASTNode* node = malloc(sizeof(ASTNode));
    if (!node) return NULL;
    
    node->type = AST_VAR_DECL;
    node->line = line;
    node->column = column;
    node->data.var_decl.name = name;
    node->data.var_decl.type = type;
    node->data.var_decl.initializer = initializer;
    
    return node;
}

/* Create assignment node */
ASTNode* create_assignment_node(const char* name, ASTNode* value, int line, int column) {
    ASTNode* node = malloc(sizeof(ASTNode));
    if (!node) return NULL;
    
    node->type = AST_ASSIGNMENT;
    node->line = line;
    node->column = column;
    node->data.assignment.name = name;
    node->data.assignment.value = value;
    
    return node;
}

/* Create if node */
ASTNode* create_if_node(ASTNode* condition, ASTNode** then_body, int then_count,
                        ASTNode** else_body, int else_count, int line, int column) {
    ASTNode* node = malloc(sizeof(ASTNode));
    if (!node) return NULL;
    
    node->type = AST_IF;
    node->line = line;
    node->column = column;
    node->data.if_stmt.condition = condition;
    node->data.if_stmt.then_body = then_body;
    node->data.if_stmt.then_count = then_count;
    node->data.if_stmt.else_body = else_body;
    node->data.if_stmt.else_count = else_count;
    
    return node;
}

/* Create while node */
ASTNode* create_while_node(ASTNode* condition, ASTNode** body, int body_count,
                           int line, int column) {
    ASTNode* node = malloc(sizeof(ASTNode));
    if (!node) return NULL;
    
    node->type = AST_WHILE;
    node->line = line;
    node->column = column;
    node->data.while_stmt.condition = condition;
    node->data.while_stmt.body = body;
    node->data.while_stmt.body_count = body_count;
    
    return node;
}

/* Create expression statement node */
ASTNode* create_expr_stmt_node(ASTNode* expression, int line, int column) {
    ASTNode* node = malloc(sizeof(ASTNode));
    if (!node) return NULL;
    
    node->type = AST_EXPR_STMT;
    node->line = line;
    node->column = column;
    node->data.return_stmt.expression = expression;  /* Reuse return_stmt union */
    
    return node;
}

/* Create binary operation node */
ASTNode* create_binary_op_node(TokenType op, ASTNode* left, ASTNode* right,
                                int line, int column) {
    ASTNode* node = malloc(sizeof(ASTNode));
    if (!node) return NULL;
    
    node->type = AST_BINARY_OP;
    node->line = line;
    node->column = column;
    node->data.binary_op.op = op;
    node->data.binary_op.left = left;
    node->data.binary_op.right = right;
    
    return node;
}

/* Create unary operation node */
ASTNode* create_unary_op_node(TokenType op, ASTNode* operand, int line, int column) {
    ASTNode* node = malloc(sizeof(ASTNode));
    if (!node) return NULL;
    
    node->type = AST_UNARY_OP;
    node->line = line;
    node->column = column;
    node->data.unary_op.op = op;
    node->data.unary_op.operand = operand;
    
    return node;
}

/* Create literal node */
ASTNode* create_literal_node(TokenType literal_type, long long int_value,
                              int line, int column) {
    ASTNode* node = malloc(sizeof(ASTNode));
    if (!node) return NULL;
    
    node->type = AST_LITERAL;
    node->line = line;
    node->column = column;
    node->data.literal.literal_type = literal_type;
    node->data.literal.value.int_value = int_value;
    
    return node;
}

/* Create identifier node */
ASTNode* create_identifier_node(const char* name, int line, int column) {
    ASTNode* node = malloc(sizeof(ASTNode));
    if (!node) return NULL;
    
    node->type = AST_IDENTIFIER;
    node->line = line;
    node->column = column;
    node->data.identifier.name = name;
    
    return node;
}

/* Create function call node */
ASTNode* create_call_node(const char* name, ASTNode** arguments, int arg_count,
                          int line, int column) {
    ASTNode* node = malloc(sizeof(ASTNode));
    if (!node) return NULL;
    
    node->type = AST_FUNCTION_CALL;
    node->line = line;
    node->column = column;
    node->data.call.name = name;
    node->data.call.arguments = arguments;
    node->data.call.argument_count = arg_count;
    
    return node;
}

/* Create type node */
ASTNode* create_type_node(TokenType type_token, int line, int column) {
    ASTNode* node = malloc(sizeof(ASTNode));
    if (!node) return NULL;
    
    node->type = AST_TYPE;
    node->line = line;
    node->column = column;
    node->data.type.type_token = type_token;
    
    return node;
}

/* Create parameter node */
ASTNode* create_parameter_node(const char* name, ASTNode* type, int line, int column) {
    ASTNode* node = malloc(sizeof(ASTNode));
    if (!node) return NULL;
    
    node->type = AST_PARAMETER;
    node->line = line;
    node->column = column;
    node->data.parameter.name = name;
    node->data.parameter.type = type;
    
    return node;
}

/* ============================================================================
 * AST MEMORY MANAGEMENT
 * ============================================================================ */

/* Free AST tree recursively */
void free_ast(ASTNode* node) {
    if (!node) return;
    
    switch (node->type) {
        case AST_PROGRAM:
            for (int i = 0; i < node->data.program.function_count; i++) {
                free_ast(node->data.program.functions[i]);
            }
            free(node->data.program.functions);
            break;
            
        case AST_FUNCTION:
            for (int i = 0; i < node->data.function.parameter_count; i++) {
                free_ast(node->data.function.parameters[i]);
            }
            free(node->data.function.parameters);
            free_ast(node->data.function.return_type);
            for (int i = 0; i < node->data.function.body_count; i++) {
                free_ast(node->data.function.body[i]);
            }
            free(node->data.function.body);
            break;
            
        case AST_RETURN:
        case AST_EXPR_STMT:
            free_ast(node->data.return_stmt.expression);
            break;
            
        case AST_VAR_DECL:
            free_ast(node->data.var_decl.type);
            free_ast(node->data.var_decl.initializer);
            break;
            
        case AST_ASSIGNMENT:
            free_ast(node->data.assignment.value);
            break;
            
        case AST_IF:
            free_ast(node->data.if_stmt.condition);
            for (int i = 0; i < node->data.if_stmt.then_count; i++) {
                free_ast(node->data.if_stmt.then_body[i]);
            }
            free(node->data.if_stmt.then_body);
            for (int i = 0; i < node->data.if_stmt.else_count; i++) {
                free_ast(node->data.if_stmt.else_body[i]);
            }
            free(node->data.if_stmt.else_body);
            break;
            
        case AST_WHILE:
            free_ast(node->data.while_stmt.condition);
            for (int i = 0; i < node->data.while_stmt.body_count; i++) {
                free_ast(node->data.while_stmt.body[i]);
            }
            free(node->data.while_stmt.body);
            break;
            
        case AST_BINARY_OP:
            free_ast(node->data.binary_op.left);
            free_ast(node->data.binary_op.right);
            break;
            
        case AST_UNARY_OP:
            free_ast(node->data.unary_op.operand);
            break;
            
        case AST_LITERAL:
            /* Nothing to free (no dynamically allocated data) */
            break;
            
        case AST_IDENTIFIER:
            /* name points to token lexeme, not owned */
            break;
            
        case AST_FUNCTION_CALL:
            for (int i = 0; i < node->data.call.argument_count; i++) {
                free_ast(node->data.call.arguments[i]);
            }
            free(node->data.call.arguments);
            break;
            
        case AST_TYPE:
            /* Nothing to free */
            break;
            
        case AST_PARAMETER:
            free_ast(node->data.parameter.type);
            break;
    }
    
    free(node);
}

/* ============================================================================
 * AST UTILITY FUNCTIONS
 * ============================================================================ */

/* Get human-readable name for AST node type */
const char* ast_node_type_name(ASTNodeType type) {
    switch (type) {
        case AST_PROGRAM: return "PROGRAM";
        case AST_FUNCTION: return "FUNCTION";
        case AST_RETURN: return "RETURN";
        case AST_VAR_DECL: return "VAR_DECL";
        case AST_ASSIGNMENT: return "ASSIGNMENT";
        case AST_IF: return "IF";
        case AST_WHILE: return "WHILE";
        case AST_EXPR_STMT: return "EXPR_STMT";
        case AST_BINARY_OP: return "BINARY_OP";
        case AST_UNARY_OP: return "UNARY_OP";
        case AST_LITERAL: return "LITERAL";
        case AST_IDENTIFIER: return "IDENTIFIER";
        case AST_FUNCTION_CALL: return "FUNCTION_CALL";
        case AST_TYPE: return "TYPE";
        case AST_PARAMETER: return "PARAMETER";
        default: return "UNKNOWN";
    }
}

/* Print AST tree (for debugging) */
void print_ast(ASTNode* node, int indent) {
    if (!node) {
        printf("%*sNULL\n", indent, "");
        return;
    }
    
    printf("%*s%s (line %d, col %d)\n", indent, "",
           ast_node_type_name(node->type), node->line, node->column);
    
    switch (node->type) {
        case AST_PROGRAM:
            for (int i = 0; i < node->data.program.function_count; i++) {
                print_ast(node->data.program.functions[i], indent + 2);
            }
            break;
            
        case AST_FUNCTION:
            printf("%*sname: %s\n", indent + 2, "", node->data.function.name);
            printf("%*sparameters:\n", indent + 2, "");
            for (int i = 0; i < node->data.function.parameter_count; i++) {
                print_ast(node->data.function.parameters[i], indent + 4);
            }
            printf("%*sreturn_type:\n", indent + 2, "");
            print_ast(node->data.function.return_type, indent + 4);
            printf("%*sbody:\n", indent + 2, "");
            for (int i = 0; i < node->data.function.body_count; i++) {
                print_ast(node->data.function.body[i], indent + 4);
            }
            break;
            
        case AST_RETURN:
            printf("%*sexpression:\n", indent + 2, "");
            print_ast(node->data.return_stmt.expression, indent + 4);
            break;
            
        case AST_VAR_DECL:
            printf("%*sname: %s\n", indent + 2, "", node->data.var_decl.name);
            printf("%*stype:\n", indent + 2, "");
            print_ast(node->data.var_decl.type, indent + 4);
            if (node->data.var_decl.initializer) {
                printf("%*sinitializer:\n", indent + 2, "");
                print_ast(node->data.var_decl.initializer, indent + 4);
            }
            break;
            
        case AST_ASSIGNMENT:
            printf("%*sname: %s\n", indent + 2, "", node->data.assignment.name);
            printf("%*svalue:\n", indent + 2, "");
            print_ast(node->data.assignment.value, indent + 4);
            break;
            
        case AST_IF:
            printf("%*scondition:\n", indent + 2, "");
            print_ast(node->data.if_stmt.condition, indent + 4);
            printf("%*sthen:\n", indent + 2, "");
            for (int i = 0; i < node->data.if_stmt.then_count; i++) {
                print_ast(node->data.if_stmt.then_body[i], indent + 4);
            }
            if (node->data.if_stmt.else_count > 0) {
                printf("%*selse:\n", indent + 2, "");
                for (int i = 0; i < node->data.if_stmt.else_count; i++) {
                    print_ast(node->data.if_stmt.else_body[i], indent + 4);
                }
            }
            break;
            
        case AST_WHILE:
            printf("%*scondition:\n", indent + 2, "");
            print_ast(node->data.while_stmt.condition, indent + 4);
            printf("%*sbody:\n", indent + 2, "");
            for (int i = 0; i < node->data.while_stmt.body_count; i++) {
                print_ast(node->data.while_stmt.body[i], indent + 4);
            }
            break;
            
        case AST_EXPR_STMT:
            printf("%*sexpression:\n", indent + 2, "");
            print_ast(node->data.return_stmt.expression, indent + 4);
            break;
            
        case AST_BINARY_OP:
            printf("%*sop: %s\n", indent + 2, "", token_type_name(node->data.binary_op.op));
            printf("%*sleft:\n", indent + 2, "");
            print_ast(node->data.binary_op.left, indent + 4);
            printf("%*sright:\n", indent + 2, "");
            print_ast(node->data.binary_op.right, indent + 4);
            break;
            
        case AST_UNARY_OP:
            printf("%*sop: %s\n", indent + 2, "", token_type_name(node->data.unary_op.op));
            printf("%*soperand:\n", indent + 2, "");
            print_ast(node->data.unary_op.operand, indent + 4);
            break;
            
        case AST_LITERAL:
            printf("%*stype: %s\n", indent + 2, "",
                   token_type_name(node->data.literal.literal_type));
            if (node->data.literal.literal_type == TOKEN_NUMBER) {
                printf("%*svalue: %lld\n", indent + 2, "",
                       node->data.literal.value.int_value);
            }
            break;
            
        case AST_IDENTIFIER:
            printf("%*sname: %s\n", indent + 2, "", node->data.identifier.name);
            break;
            
        case AST_FUNCTION_CALL:
            printf("%*sname: %s\n", indent + 2, "", node->data.call.name);
            printf("%*sarguments:\n", indent + 2, "");
            for (int i = 0; i < node->data.call.argument_count; i++) {
                print_ast(node->data.call.arguments[i], indent + 4);
            }
            break;
            
        case AST_TYPE:
            printf("%*stype: %s\n", indent + 2, "",
                   token_type_name(node->data.type.type_token));
            break;
            
        case AST_PARAMETER:
            printf("%*sname: %s\n", indent + 2, "", node->data.parameter.name);
            printf("%*stype:\n", indent + 2, "");
            print_ast(node->data.parameter.type, indent + 4);
            break;
    }
}
