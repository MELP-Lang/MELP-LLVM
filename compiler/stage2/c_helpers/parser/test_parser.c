/* MELP Stage 2 - Parser Test Suite
 * Generated by: YZ_03 (Parser Specialist)
 * Date: 16 Ocak 2026
 * Phase: 3.0 - Parser Implementation (Task 3.4)
 * 
 * Comprehensive test suite for parser with >15 test cases.
 * 
 * Test Coverage:
 * - Basic expressions (literals, identifiers, binary ops)
 * - Function declarations and calls
 * - Variable declarations and assignments
 * - Control flow (if-then-else, while loops)
 * - Operator precedence and associativity
 * - Error handling
 */

#include "../parser/parser_impl.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Test counter */
static int tests_passed = 0;
static int tests_failed = 0;

/* ============================================================================
 * TEST UTILITIES
 * ============================================================================ */

#define TEST(name) \
    do { \
        printf("\nüîç Test: %s\n", #name); \
        test_##name(); \
    } while (0)

#define ASSERT(condition, message) \
    do { \
        if (!(condition)) { \
            printf("  ‚ùå FAILED: %s\n", message); \
            tests_failed++; \
            return 0; \
        } \
    } while (0)

#define ASSERT_NOT_NULL(ptr, message) \
    ASSERT((ptr) != NULL, message)

#define ASSERT_NULL(ptr, message) \
    ASSERT((ptr) == NULL, message)

#define ASSERT_EQUAL(actual, expected, message) \
    ASSERT((actual) == (expected), message)

#define PASS() \
    do { \
        printf("  ‚úÖ PASSED\n"); \
        tests_passed++; \
        return 1; \
    } while (0)

/* ============================================================================
 * TEST CASES
 * ============================================================================ */

/* Test 1: Empty program */
int test_empty_program(void) {
    const char* source = "";
    ASTNode* ast = parse(source);
    
    ASSERT_NOT_NULL(ast, "AST should not be NULL for empty program");
    ASSERT_EQUAL(ast->type, AST_PROGRAM, "Root should be PROGRAM node");
    ASSERT_EQUAL(ast->data.program.function_count, 0, "Empty program should have 0 functions");
    
    free_ast(ast);
    PASS();
}

/* Test 2: Simple function */
int test_simple_function(void) {
    const char* source = 
        "function main() as numeric\n"
        "  return 42\n"
        "end_function\n";
    
    ASTNode* ast = parse(source);
    
    ASSERT_NOT_NULL(ast, "AST should not be NULL");
    ASSERT_EQUAL(ast->type, AST_PROGRAM, "Root should be PROGRAM");
    ASSERT_EQUAL(ast->data.program.function_count, 1, "Should have 1 function");
    
    ASTNode* func = ast->data.program.functions[0];
    ASSERT_EQUAL(func->type, AST_FUNCTION, "Should be FUNCTION node");
    ASSERT_EQUAL(func->data.function.parameter_count, 0, "Should have 0 parameters");
    ASSERT_EQUAL(func->data.function.body_count, 1, "Should have 1 statement");
    
    ASTNode* return_stmt = func->data.function.body[0];
    ASSERT_EQUAL(return_stmt->type, AST_RETURN, "Should be RETURN node");
    ASSERT_NOT_NULL(return_stmt->data.return_stmt.expression, "Return should have expression");
    
    free_ast(ast);
    PASS();
}

/* Test 3: Function with parameters */
int test_function_with_parameters(void) {
    const char* source = 
        "function add(numeric a; numeric b) as numeric\n"
        "  return a + b\n"
        "end_function\n";
    
    ASTNode* ast = parse(source);
    
    ASSERT_NOT_NULL(ast, "AST should not be NULL");
    
    ASTNode* func = ast->data.program.functions[0];
    ASSERT_EQUAL(func->data.function.parameter_count, 2, "Should have 2 parameters");
    
    ASTNode* param1 = func->data.function.parameters[0];
    ASSERT_EQUAL(param1->type, AST_PARAMETER, "Should be PARAMETER node");
    
    free_ast(ast);
    PASS();
}

/* Test 4: Variable declaration */
int test_variable_declaration(void) {
    const char* source = 
        "function test() as numeric\n"
        "  numeric x = 10\n"
        "  return x\n"
        "end_function\n";
    
    ASTNode* ast = parse(source);
    
    ASSERT_NOT_NULL(ast, "AST should not be NULL");
    
    ASTNode* func = ast->data.program.functions[0];
    ASSERT_EQUAL(func->data.function.body_count, 2, "Should have 2 statements");
    
    ASTNode* var_decl = func->data.function.body[0];
    ASSERT_EQUAL(var_decl->type, AST_VAR_DECL, "Should be VAR_DECL node");
    ASSERT_NOT_NULL(var_decl->data.var_decl.initializer, "Should have initializer");
    
    free_ast(ast);
    PASS();
}

/* Test 5: Variable assignment */
int test_variable_assignment(void) {
    const char* source = 
        "function test() as numeric\n"
        "  numeric x = 10\n"
        "  x = 20\n"
        "  return x\n"
        "end_function\n";
    
    ASTNode* ast = parse(source);
    
    ASSERT_NOT_NULL(ast, "AST should not be NULL");
    
    ASTNode* func = ast->data.program.functions[0];
    ASTNode* assignment = func->data.function.body[1];
    ASSERT_EQUAL(assignment->type, AST_ASSIGNMENT, "Should be ASSIGNMENT node");
    
    free_ast(ast);
    PASS();
}

/* Test 6: Binary operations */
int test_binary_operations(void) {
    const char* source = 
        "function calc() as numeric\n"
        "  return 10 + 20 * 3\n"
        "end_function\n";
    
    ASTNode* ast = parse(source);
    
    ASSERT_NOT_NULL(ast, "AST should not be NULL");
    
    ASTNode* func = ast->data.program.functions[0];
    ASTNode* return_stmt = func->data.function.body[0];
    ASTNode* expr = return_stmt->data.return_stmt.expression;
    
    ASSERT_EQUAL(expr->type, AST_BINARY_OP, "Should be BINARY_OP");
    ASSERT_EQUAL(expr->data.binary_op.op, TOKEN_PLUS, "Top-level should be +");
    
    ASTNode* right = expr->data.binary_op.right;
    ASSERT_EQUAL(right->type, AST_BINARY_OP, "Right should be BINARY_OP");
    ASSERT_EQUAL(right->data.binary_op.op, TOKEN_STAR, "Right should be *");
    
    free_ast(ast);
    PASS();
}

/* Test 7: Comparison operations */
int test_comparison_operations(void) {
    const char* source = 
        "function compare() as boolean\n"
        "  return 10 > 5\n"
        "end_function\n";
    
    ASTNode* ast = parse(source);
    
    ASSERT_NOT_NULL(ast, "AST should not be NULL");
    
    ASTNode* func = ast->data.program.functions[0];
    ASTNode* return_stmt = func->data.function.body[0];
    ASTNode* expr = return_stmt->data.return_stmt.expression;
    
    ASSERT_EQUAL(expr->type, AST_BINARY_OP, "Should be BINARY_OP");
    ASSERT_EQUAL(expr->data.binary_op.op, TOKEN_GREATER, "Should be >");
    
    free_ast(ast);
    PASS();
}

/* Test 8: Logical operations */
int test_logical_operations(void) {
    const char* source = 
        "function logic() as boolean\n"
        "  return true and false or true\n"
        "end_function\n";
    
    ASTNode* ast = parse(source);
    
    ASSERT_NOT_NULL(ast, "AST should not be NULL");
    
    ASTNode* func = ast->data.program.functions[0];
    ASTNode* return_stmt = func->data.function.body[0];
    ASTNode* expr = return_stmt->data.return_stmt.expression;
    
    ASSERT_EQUAL(expr->type, AST_BINARY_OP, "Should be BINARY_OP");
    ASSERT_EQUAL(expr->data.binary_op.op, TOKEN_OR, "Top-level should be OR");
    
    free_ast(ast);
    PASS();
}

/* Test 9: Unary operations */
int test_unary_operations(void) {
    const char* source = 
        "function negate() as boolean\n"
        "  return not true\n"
        "end_function\n";
    
    ASTNode* ast = parse(source);
    
    ASSERT_NOT_NULL(ast, "AST should not be NULL");
    
    ASTNode* func = ast->data.program.functions[0];
    ASTNode* return_stmt = func->data.function.body[0];
    ASTNode* expr = return_stmt->data.return_stmt.expression;
    
    ASSERT_EQUAL(expr->type, AST_UNARY_OP, "Should be UNARY_OP");
    ASSERT_EQUAL(expr->data.unary_op.op, TOKEN_NOT, "Should be NOT");
    
    free_ast(ast);
    PASS();
}

/* Test 10: If statement */
int test_if_statement(void) {
    const char* source = 
        "function test() as numeric\n"
        "  if true then\n"
        "    return 1\n"
        "  end_if\n"
        "  return 0\n"
        "end_function\n";
    
    ASTNode* ast = parse(source);
    
    ASSERT_NOT_NULL(ast, "AST should not be NULL");
    
    ASTNode* func = ast->data.program.functions[0];
    ASTNode* if_stmt = func->data.function.body[0];
    
    ASSERT_EQUAL(if_stmt->type, AST_IF, "Should be IF node");
    ASSERT_NOT_NULL(if_stmt->data.if_stmt.condition, "Should have condition");
    ASSERT_EQUAL(if_stmt->data.if_stmt.then_count, 1, "Should have 1 then statement");
    
    free_ast(ast);
    PASS();
}

/* Test 11: If-else statement */
int test_if_else_statement(void) {
    const char* source = 
        "function test() as numeric\n"
        "  if false then\n"
        "    return 1\n"
        "  else\n"
        "    return 0\n"
        "  end_if\n"
        "end_function\n";
    
    ASTNode* ast = parse(source);
    
    ASSERT_NOT_NULL(ast, "AST should not be NULL");
    
    ASTNode* func = ast->data.program.functions[0];
    ASTNode* if_stmt = func->data.function.body[0];
    
    ASSERT_EQUAL(if_stmt->type, AST_IF, "Should be IF node");
    ASSERT_EQUAL(if_stmt->data.if_stmt.else_count, 1, "Should have 1 else statement");
    
    free_ast(ast);
    PASS();
}

/* Test 12: While loop */
int test_while_loop(void) {
    const char* source = 
        "function loop() as numeric\n"
        "  numeric i = 0\n"
        "  while i < 10\n"
        "    i = i + 1\n"
        "  end_while\n"
        "  return i\n"
        "end_function\n";
    
    ASTNode* ast = parse(source);
    
    ASSERT_NOT_NULL(ast, "AST should not be NULL");
    
    ASTNode* func = ast->data.program.functions[0];
    ASTNode* while_stmt = func->data.function.body[1];
    
    ASSERT_EQUAL(while_stmt->type, AST_WHILE, "Should be WHILE node");
    ASSERT_NOT_NULL(while_stmt->data.while_stmt.condition, "Should have condition");
    ASSERT_EQUAL(while_stmt->data.while_stmt.body_count, 1, "Should have 1 body statement");
    
    free_ast(ast);
    PASS();
}

/* Test 13: Function call */
int test_function_call(void) {
    const char* source = 
        "function main() as numeric\n"
        "  return add(10; 20)\n"
        "end_function\n";
    
    ASTNode* ast = parse(source);
    
    ASSERT_NOT_NULL(ast, "AST should not be NULL");
    
    ASTNode* func = ast->data.program.functions[0];
    ASTNode* return_stmt = func->data.function.body[0];
    ASTNode* call = return_stmt->data.return_stmt.expression;
    
    ASSERT_EQUAL(call->type, AST_FUNCTION_CALL, "Should be FUNCTION_CALL");
    ASSERT_EQUAL(call->data.call.argument_count, 2, "Should have 2 arguments");
    
    free_ast(ast);
    PASS();
}

/* Test 14: Expression statement (function call) */
int test_expression_statement(void) {
    const char* source = 
        "function main() as numeric\n"
        "  print(42)\n"
        "  return 0\n"
        "end_function\n";
    
    ASTNode* ast = parse(source);
    
    ASSERT_NOT_NULL(ast, "AST should not be NULL");
    
    ASTNode* func = ast->data.program.functions[0];
    ASTNode* expr_stmt = func->data.function.body[0];
    
    ASSERT_EQUAL(expr_stmt->type, AST_EXPR_STMT, "Should be EXPR_STMT");
    ASSERT_NOT_NULL(expr_stmt->data.return_stmt.expression, "Should have expression");
    
    free_ast(ast);
    PASS();
}

/* Test 15: Multiple functions */
int test_multiple_functions(void) {
    const char* source = 
        "function add(numeric a; numeric b) as numeric\n"
        "  return a + b\n"
        "end_function\n"
        "\n"
        "function main() as numeric\n"
        "  return add(10; 20)\n"
        "end_function\n";
    
    ASTNode* ast = parse(source);
    
    ASSERT_NOT_NULL(ast, "AST should not be NULL");
    ASSERT_EQUAL(ast->data.program.function_count, 2, "Should have 2 functions");
    
    free_ast(ast);
    PASS();
}

/* Test 16: Parenthesized expression */
int test_parenthesized_expression(void) {
    const char* source = 
        "function calc() as numeric\n"
        "  return (10 + 20) * 3\n"
        "end_function\n";
    
    ASTNode* ast = parse(source);
    
    ASSERT_NOT_NULL(ast, "AST should not be NULL");
    
    ASTNode* func = ast->data.program.functions[0];
    ASTNode* return_stmt = func->data.function.body[0];
    ASTNode* expr = return_stmt->data.return_stmt.expression;
    
    ASSERT_EQUAL(expr->type, AST_BINARY_OP, "Should be BINARY_OP");
    ASSERT_EQUAL(expr->data.binary_op.op, TOKEN_STAR, "Top-level should be *");
    
    free_ast(ast);
    PASS();
}

/* Test 17: Complex expression with precedence */
int test_operator_precedence(void) {
    const char* source = 
        "function test() as numeric\n"
        "  return 1 + 2 * 3 + 4\n"
        "end_function\n";
    
    ASTNode* ast = parse(source);
    
    ASSERT_NOT_NULL(ast, "AST should not be NULL");
    
    ASTNode* func = ast->data.program.functions[0];
    ASTNode* return_stmt = func->data.function.body[0];
    ASTNode* expr = return_stmt->data.return_stmt.expression;
    
    /* Should be: (1 + (2 * 3)) + 4 */
    ASSERT_EQUAL(expr->type, AST_BINARY_OP, "Should be BINARY_OP");
    ASSERT_EQUAL(expr->data.binary_op.op, TOKEN_PLUS, "Top-level should be +");
    
    free_ast(ast);
    PASS();
}

/* Test 18: Error handling - missing end_function */
int test_error_missing_end_function(void) {
    const char* source = 
        "function main() as numeric\n"
        "  return 42\n";  /* Missing end_function */
    
    ASTNode* ast = parse(source);
    
    ASSERT_NULL(ast, "AST should be NULL for invalid syntax");
    
    const char* error = get_parse_error();
    ASSERT_NOT_NULL(error, "Should have error message");
    
    PASS();
}

/* Test 19: Error handling - missing function name */
int test_error_missing_function_name(void) {
    const char* source = 
        "function () as numeric\n"  /* Missing name */
        "  return 42\n"
        "end_function\n";
    
    ASTNode* ast = parse(source);
    
    ASSERT_NULL(ast, "AST should be NULL for invalid syntax");
    
    const char* error = get_parse_error();
    ASSERT_NOT_NULL(error, "Should have error message");
    
    PASS();
}

/* Test 20: Error handling - invalid expression */
int test_error_invalid_expression(void) {
    const char* source = 
        "function test() as numeric\n"
        "  return 42 +\n"  /* Incomplete expression */
        "end_function\n";
    
    ASTNode* ast = parse(source);
    
    ASSERT_NULL(ast, "AST should be NULL for invalid syntax");
    
    const char* error = get_parse_error();
    ASSERT_NOT_NULL(error, "Should have error message");
    
    PASS();
}

/* ============================================================================
 * MAIN TEST RUNNER
 * ============================================================================ */

int main(void) {
    printf("==============================================\n");
    printf("MELP Stage 2 - Parser Test Suite\n");
    printf("==============================================\n");
    
    TEST(empty_program);
    TEST(simple_function);
    TEST(function_with_parameters);
    TEST(variable_declaration);
    TEST(variable_assignment);
    TEST(binary_operations);
    TEST(comparison_operations);
    TEST(logical_operations);
    TEST(unary_operations);
    TEST(if_statement);
    TEST(if_else_statement);
    TEST(while_loop);
    TEST(function_call);
    TEST(expression_statement);
    TEST(multiple_functions);
    TEST(parenthesized_expression);
    TEST(operator_precedence);
    TEST(error_missing_end_function);
    TEST(error_missing_function_name);
    TEST(error_invalid_expression);
    
    printf("\n==============================================\n");
    printf("Test Results:\n");
    printf("  ‚úÖ Passed: %d\n", tests_passed);
    printf("  ‚ùå Failed: %d\n", tests_failed);
    printf("  üìä Total:  %d\n", tests_passed + tests_failed);
    printf("==============================================\n");
    
    if (tests_failed == 0) {
        printf("üéâ All tests passed!\n");
        return 0;
    } else {
        printf("‚ö†Ô∏è  Some tests failed!\n");
        return 1;
    }
}
