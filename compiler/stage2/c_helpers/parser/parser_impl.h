#ifndef PARSER_IMPL_H
#define PARSER_IMPL_H

/* MELP Stage 2 - Parser Interface
 * Generated by: YZ_03 (Parser Specialist)
 * Date: 16 Ocak 2026
 * Phase: 3.0 - Parser Implementation (Task 3.2)
 * 
 * This header defines the public API for the parser module.
 * 
 * Design Principles (AUTONOMOUS):
 * - Single responsibility: Token array → AST transformation
 * - Peer to lexer: Imports lexer_impl.h, calls tokenize()
 * - Recursive descent: Clear grammar implementation
 * - Error reporting: Detailed messages with line/column info
 */

#include "../common/ast.h"
#include "../common/token.h"
#include "../lexer/lexer_impl.h"

/* ============================================================================
 * MAIN API
 * ============================================================================ */

/* Parse source code into Abstract Syntax Tree
 * 
 * Parameters:
 *   source - Input source code (null-terminated string)
 * 
 * Returns:
 *   ASTNode* - Root AST_PROGRAM node
 *              Returns NULL on parse error
 *              Caller MUST call free_ast() when done
 * 
 * Behavior:
 *   1. Tokenizes source via lexer (peer call)
 *   2. Parses tokens into AST using recursive descent
 *   3. Reports parse errors to stderr with context
 *   4. Cleans up tokens internally
 * 
 * Error Handling:
 *   - Syntax errors → prints detailed error message, returns NULL
 *   - Unexpected tokens → reports expected vs actual
 *   - Premature EOF → reports incomplete construct
 * 
 * Grammar (PMLP0/PMLP1 - Simplified):
 *   program        → function*
 *   function       → "function" IDENT "(" params? ")" "as" type
 *                    statement* "end_function"
 *   params         → param (";" param)*
 *   param          → type IDENT
 *   type           → "numeric" | "boolean"
 *   statement      → var_decl | assignment | if_stmt | while_stmt
 *                  | return_stmt | expr_stmt | NEWLINE
 *   var_decl       → type IDENT ("=" expression)? NEWLINE
 *   assignment     → IDENT "=" expression NEWLINE
 *   if_stmt        → "if" expression "then" NEWLINE
 *                    statement*
 *                    ("else" NEWLINE statement*)?
 *                    "end_if" NEWLINE
 *   while_stmt     → "while" expression NEWLINE
 *                    statement* "end_while" NEWLINE
 *   return_stmt    → "return" expression? NEWLINE
 *   expr_stmt      → expression NEWLINE
 *   expression     → logical_or
 *   logical_or     → logical_and ("or" logical_and)*
 *   logical_and    → equality ("and" equality)*
 *   equality       → comparison (("==" | "!=") comparison)*
 *   comparison     → term (("<" | "<=" | ">" | ">=") term)*
 *   term           → factor (("+" | "-") factor)*
 *   factor         → unary (("*" | "/" | "mod") unary)*
 *   unary          → ("not" | "-") unary | primary
 *   primary        → NUMBER | "true" | "false" | IDENT | call | "(" expression ")"
 *   call           → IDENT "(" args? ")"
 *   args           → expression (";" expression)*
 * 
 * Example:
 *   const char* source = "function add(numeric a; numeric b) as numeric\n"
 *                        "  return a + b\n"
 *                        "end_function\n";
 *   ASTNode* ast = parse(source);
 *   if (ast) {
 *       // Use AST...
 *       free_ast(ast);
 *   }
 */
ASTNode* parse(const char* source);

/* ============================================================================
 * ERROR REPORTING
 * ============================================================================ */

/* Get last parser error message
 * 
 * Returns:
 *   const char* - Last error message (static buffer)
 *                 Valid until next parse() call
 *                 Returns NULL if no error
 * 
 * Example:
 *   ASTNode* ast = parse(source);
 *   if (!ast) {
 *       fprintf(stderr, "Parse error: %s\n", get_parse_error());
 *   }
 */
const char* get_parse_error(void);

/* ============================================================================
 * UTILITY FUNCTIONS (For testing and debugging)
 * ============================================================================ */

/* Parse token array directly (for testing)
 * 
 * Useful for testing parser without going through lexer.
 * 
 * Parameters:
 *   tokens - Array of tokens (must end with TOKEN_EOF)
 *   count  - Number of tokens (including EOF)
 * 
 * Returns:
 *   ASTNode* - Root AST_PROGRAM node (or NULL on error)
 * 
 * Note: Tokens are NOT freed by this function (caller's responsibility)
 */
ASTNode* parse_tokens(Token* tokens, int count);

#endif /* PARSER_IMPL_H */
