/* MELP Stage 2 - Parser Implementation
 * Generated by: YZ_03 (Parser Specialist)
 * Date: 16 Ocak 2026
 * Phase: 3.0 - Parser Implementation (Task 3.3)
 * 
 * Recursive descent parser for PMLP0/PMLP1 syntax.
 * 
 * Design:
 * - Recursive descent (one function per grammar rule)
 * - Single-token lookahead
 * - Error recovery: Report first error and bail out
 * - Memory management: Free partial ASTs on error
 */

#include "parser_impl.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ============================================================================
 * PARSER STATE
 * ============================================================================ */

/* Parser state structure
 * 
 * Maintains current position in token stream and error information.
 */
typedef struct {
    Token* tokens;            /* Token array */
    int count;                /* Total token count */
    int current;              /* Current token index */
    char error_message[512];  /* Last error message */
    int has_error;            /* Error flag */
} Parser;

/* Global parser state (for simplicity) */
static Parser parser;

/* ============================================================================
 * FORWARD DECLARATIONS
 * ============================================================================ */

static ASTNode* parse_function(void);
static ASTNode* parse_statement(void);
static ASTNode* parse_var_decl(void);
static ASTNode* parse_assignment_or_expr(void);
static ASTNode* parse_if_statement(void);
static ASTNode* parse_while_statement(void);
static ASTNode* parse_return_statement(void);
static ASTNode* parse_expression(void);
static ASTNode* parse_logical_or(void);
static ASTNode* parse_logical_and(void);
static ASTNode* parse_equality(void);
static ASTNode* parse_comparison(void);
static ASTNode* parse_term(void);
static ASTNode* parse_factor(void);
static ASTNode* parse_unary(void);
static ASTNode* parse_primary(void);
static ASTNode* parse_call(const char* name, int line, int column);

/* ============================================================================
 * UTILITY FUNCTIONS
 * ============================================================================ */

/* Get current token */
static Token* current_token(void) {
    if (parser.current >= parser.count) {
        return &parser.tokens[parser.count - 1];  /* Return EOF */
    }
    return &parser.tokens[parser.current];
}

/* Get previous token */
static Token* previous_token(void) {
    if (parser.current == 0) return &parser.tokens[0];
    return &parser.tokens[parser.current - 1];
}

/* Check if current token matches given type */
static int check(TokenType type) {
    if (parser.current >= parser.count) return 0;
    return current_token()->type == type;
}

/* Check if at end of file */
static int is_at_end(void) {
    return check(TOKEN_EOF);
}

/* Advance to next token */
static Token* advance(void) {
    if (!is_at_end()) parser.current++;
    return previous_token();
}

/* Check and consume token if it matches */
static int match(TokenType type) {
    if (check(type)) {
        advance();
        return 1;
    }
    return 0;
}

/* Skip newline tokens */
static void skip_newlines(void) {
    while (match(TOKEN_NEWLINE)) {
        /* Skip */
    }
}

/* Expect a specific token type and consume it */
static Token* expect(TokenType type, const char* message) {
    if (check(type)) {
        return advance();
    }
    
    /* Error: unexpected token */
    Token* tok = current_token();
    snprintf(parser.error_message, sizeof(parser.error_message),
             "%s at line %d, column %d. Got '%.*s' (%s)",
             message, tok->line, tok->column,
             tok->lexeme_length, tok->lexeme,
             token_type_name(tok->type));
    parser.has_error = 1;
    return NULL;
}

/* Report error and set error flag */
static void error_at(Token* token, const char* message) {
    snprintf(parser.error_message, sizeof(parser.error_message),
             "%s at line %d, column %d",
             message, token->line, token->column);
    parser.has_error = 1;
}

/* ============================================================================
 * PARSER FUNCTIONS (Grammar Rules)
 * ============================================================================ */

/* Parse program: function* */
static ASTNode* parse_program(void) {
    /* Collect all functions */
    ASTNode** functions = NULL;
    int function_count = 0;
    int capacity = 4;
    
    functions = malloc(sizeof(ASTNode*) * capacity);
    if (!functions) {
        snprintf(parser.error_message, sizeof(parser.error_message),
                 "Out of memory allocating function array");
        parser.has_error = 1;
        return NULL;
    }
    
    skip_newlines();
    
    while (!is_at_end()) {
        ASTNode* func = parse_function();
        if (!func) {
            /* Error occurred, cleanup */
            for (int i = 0; i < function_count; i++) {
                free_ast(functions[i]);
            }
            free(functions);
            return NULL;
        }
        
        /* Expand array if needed */
        if (function_count >= capacity) {
            capacity *= 2;
            ASTNode** new_functions = realloc(functions, sizeof(ASTNode*) * capacity);
            if (!new_functions) {
                free_ast(func);
                for (int i = 0; i < function_count; i++) {
                    free_ast(functions[i]);
                }
                free(functions);
                snprintf(parser.error_message, sizeof(parser.error_message),
                         "Out of memory expanding function array");
                parser.has_error = 1;
                return NULL;
            }
            functions = new_functions;
        }
        
        functions[function_count++] = func;
        skip_newlines();
    }
    
    return create_program_node(functions, function_count, 1, 1);
}

/* Parse function: "function" IDENT "(" params? ")" "as" type statement* "end_function" */
static ASTNode* parse_function(void) {
    Token* func_token = expect(TOKEN_FUNCTION, "Expected 'function'");
    if (!func_token) return NULL;
    
    Token* name_token = expect(TOKEN_IDENTIFIER, "Expected function name");
    if (!name_token) return NULL;
    
    const char* name = name_token->lexeme;  /* Points to token, no copy needed */
    
    if (!expect(TOKEN_LEFT_PAREN, "Expected '(' after function name")) return NULL;
    
    /* Parse parameters */
    ASTNode** parameters = NULL;
    int param_count = 0;
    int param_capacity = 4;
    
    if (!check(TOKEN_RIGHT_PAREN)) {
        parameters = malloc(sizeof(ASTNode*) * param_capacity);
        if (!parameters) {
            error_at(name_token, "Out of memory allocating parameters");
            return NULL;
        }
        
        do {
            /* Parse: type IDENT */
            TokenType type_token = current_token()->type;
            if (type_token != TOKEN_NUMERIC && type_token != TOKEN_BOOLEAN) {
                for (int i = 0; i < param_count; i++) free_ast(parameters[i]);
                free(parameters);
                expect(TOKEN_NUMERIC, "Expected parameter type (numeric or boolean)");
                return NULL;
            }
            Token* type_tok = advance();
            ASTNode* type_node = create_type_node(type_token, type_tok->line, type_tok->column);
            
            Token* param_name = expect(TOKEN_IDENTIFIER, "Expected parameter name");
            if (!param_name) {
                free_ast(type_node);
                for (int i = 0; i < param_count; i++) free_ast(parameters[i]);
                free(parameters);
                return NULL;
            }
            
            ASTNode* param = create_parameter_node(param_name->lexeme, type_node,
                                                   param_name->line, param_name->column);
            
            /* Expand array if needed */
            if (param_count >= param_capacity) {
                param_capacity *= 2;
                ASTNode** new_params = realloc(parameters, sizeof(ASTNode*) * param_capacity);
                if (!new_params) {
                    free_ast(param);
                    for (int i = 0; i < param_count; i++) free_ast(parameters[i]);
                    free(parameters);
                    error_at(param_name, "Out of memory expanding parameters");
                    return NULL;
                }
                parameters = new_params;
            }
            
            parameters[param_count++] = param;
            
        } while (match(TOKEN_SEMICOLON));
    }
    
    if (!expect(TOKEN_RIGHT_PAREN, "Expected ')' after parameters")) {
        for (int i = 0; i < param_count; i++) free_ast(parameters[i]);
        free(parameters);
        return NULL;
    }
    
    if (!expect(TOKEN_AS, "Expected 'as' before return type")) {
        for (int i = 0; i < param_count; i++) free_ast(parameters[i]);
        free(parameters);
        return NULL;
    }
    
    /* Parse return type */
    TokenType ret_type_token = current_token()->type;
    if (ret_type_token != TOKEN_NUMERIC && ret_type_token != TOKEN_BOOLEAN) {
        for (int i = 0; i < param_count; i++) free_ast(parameters[i]);
        free(parameters);
        expect(TOKEN_NUMERIC, "Expected return type (numeric or boolean)");
        return NULL;
    }
    Token* ret_type_tok = advance();
    ASTNode* return_type = create_type_node(ret_type_token, ret_type_tok->line, ret_type_tok->column);
    
    skip_newlines();
    
    /* Parse function body */
    ASTNode** body = NULL;
    int body_count = 0;
    int body_capacity = 8;
    
    body = malloc(sizeof(ASTNode*) * body_capacity);
    if (!body) {
        free_ast(return_type);
        for (int i = 0; i < param_count; i++) free_ast(parameters[i]);
        free(parameters);
        error_at(ret_type_tok, "Out of memory allocating body");
        return NULL;
    }
    
    while (!check(TOKEN_END_FUNCTION) && !is_at_end()) {
        ASTNode* stmt = parse_statement();
        if (!stmt) {
            free_ast(return_type);
            for (int i = 0; i < param_count; i++) free_ast(parameters[i]);
            free(parameters);
            for (int i = 0; i < body_count; i++) free_ast(body[i]);
            free(body);
            return NULL;
        }
        
        /* Skip empty statements (just newlines) */
        if (stmt->type == AST_EXPR_STMT && stmt->data.return_stmt.expression == NULL) {
            free_ast(stmt);
            continue;
        }
        
        /* Expand array if needed */
        if (body_count >= body_capacity) {
            body_capacity *= 2;
            ASTNode** new_body = realloc(body, sizeof(ASTNode*) * body_capacity);
            if (!new_body) {
                free_ast(stmt);
                free_ast(return_type);
                for (int i = 0; i < param_count; i++) free_ast(parameters[i]);
                free(parameters);
                for (int i = 0; i < body_count; i++) free_ast(body[i]);
                free(body);
                error_at(current_token(), "Out of memory expanding body");
                return NULL;
            }
            body = new_body;
        }
        
        body[body_count++] = stmt;
    }
    
    if (!expect(TOKEN_END_FUNCTION, "Expected 'end_function'")) {
        free_ast(return_type);
        for (int i = 0; i < param_count; i++) free_ast(parameters[i]);
        free(parameters);
        for (int i = 0; i < body_count; i++) free_ast(body[i]);
        free(body);
        return NULL;
    }
    
    skip_newlines();
    
    return create_function_node(name, parameters, param_count, return_type,
                                body, body_count, func_token->line, func_token->column);
}

/* Parse statement */
static ASTNode* parse_statement(void) {
    skip_newlines();
    
    /* Return statement */
    if (check(TOKEN_RETURN)) {
        return parse_return_statement();
    }
    
    /* If statement */
    if (check(TOKEN_IF)) {
        return parse_if_statement();
    }
    
    /* While statement */
    if (check(TOKEN_WHILE)) {
        return parse_while_statement();
    }
    
    /* Variable declaration (type IDENT ...) */
    if (check(TOKEN_NUMERIC) || check(TOKEN_BOOLEAN)) {
        return parse_var_decl();
    }
    
    /* Assignment or expression statement */
    if (check(TOKEN_IDENTIFIER)) {
        return parse_assignment_or_expr();
    }
    
    /* Empty statement (just newline) */
    if (match(TOKEN_NEWLINE)) {
        return create_expr_stmt_node(NULL, previous_token()->line, previous_token()->column);
    }
    
    /* Error: unexpected token */
    Token* tok = current_token();
    snprintf(parser.error_message, sizeof(parser.error_message),
             "Unexpected token at line %d, column %d: '%.*s'",
             tok->line, tok->column, tok->lexeme_length, tok->lexeme);
    parser.has_error = 1;
    return NULL;
}

/* Parse variable declaration: type IDENT ("=" expression)? NEWLINE */
static ASTNode* parse_var_decl(void) {
    TokenType type_token = current_token()->type;
    Token* type_tok = advance();
    
    Token* name_token = expect(TOKEN_IDENTIFIER, "Expected variable name");
    if (!name_token) return NULL;
    
    ASTNode* type_node = create_type_node(type_token, type_tok->line, type_tok->column);
    ASTNode* initializer = NULL;
    
    /* Optional initializer */
    if (match(TOKEN_EQUAL)) {
        initializer = parse_expression();
        if (!initializer) {
            free_ast(type_node);
            return NULL;
        }
    }
    
    if (!expect(TOKEN_NEWLINE, "Expected newline after variable declaration")) {
        free_ast(type_node);
        free_ast(initializer);
        return NULL;
    }
    
    return create_var_decl_node(name_token->lexeme, type_node, initializer,
                                name_token->line, name_token->column);
}

/* Parse assignment or expression statement: IDENT = expression | expression */
static ASTNode* parse_assignment_or_expr(void) {
    Token* name_token = advance();  /* IDENTIFIER */
    
    /* Check if assignment (IDENT = ...) */
    if (match(TOKEN_EQUAL)) {
        ASTNode* value = parse_expression();
        if (!value) return NULL;
        
        if (!expect(TOKEN_NEWLINE, "Expected newline after assignment")) {
            free_ast(value);
            return NULL;
        }
        
        return create_assignment_node(name_token->lexeme, value,
                                      name_token->line, name_token->column);
    }
    
    /* Otherwise, it's an expression statement (function call) */
    /* Backtrack and parse as expression */
    parser.current--;  /* Back up to IDENTIFIER */
    ASTNode* expr = parse_expression();
    if (!expr) return NULL;
    
    if (!expect(TOKEN_NEWLINE, "Expected newline after expression")) {
        free_ast(expr);
        return NULL;
    }
    
    return create_expr_stmt_node(expr, name_token->line, name_token->column);
}

/* Parse if statement */
static ASTNode* parse_if_statement(void) {
    Token* if_token = advance();  /* IF */
    
    ASTNode* condition = parse_expression();
    if (!condition) return NULL;
    
    if (!expect(TOKEN_THEN, "Expected 'then' after if condition")) {
        free_ast(condition);
        return NULL;
    }
    
    skip_newlines();
    
    /* Parse then body */
    ASTNode** then_body = NULL;
    int then_count = 0;
    int then_capacity = 8;
    
    then_body = malloc(sizeof(ASTNode*) * then_capacity);
    if (!then_body) {
        free_ast(condition);
        error_at(if_token, "Out of memory allocating then body");
        return NULL;
    }
    
    while (!check(TOKEN_ELSE) && !check(TOKEN_END_IF) && !is_at_end()) {
        ASTNode* stmt = parse_statement();
        if (!stmt) {
            free_ast(condition);
            for (int i = 0; i < then_count; i++) free_ast(then_body[i]);
            free(then_body);
            return NULL;
        }
        
        /* Skip empty statements */
        if (stmt->type == AST_EXPR_STMT && stmt->data.return_stmt.expression == NULL) {
            free_ast(stmt);
            continue;
        }
        
        /* Expand array if needed */
        if (then_count >= then_capacity) {
            then_capacity *= 2;
            ASTNode** new_then = realloc(then_body, sizeof(ASTNode*) * then_capacity);
            if (!new_then) {
                free_ast(stmt);
                free_ast(condition);
                for (int i = 0; i < then_count; i++) free_ast(then_body[i]);
                free(then_body);
                error_at(current_token(), "Out of memory expanding then body");
                return NULL;
            }
            then_body = new_then;
        }
        
        then_body[then_count++] = stmt;
    }
    
    /* Parse optional else body */
    ASTNode** else_body = NULL;
    int else_count = 0;
    
    if (match(TOKEN_ELSE)) {
        skip_newlines();
        
        int else_capacity = 8;
        else_body = malloc(sizeof(ASTNode*) * else_capacity);
        if (!else_body) {
            free_ast(condition);
            for (int i = 0; i < then_count; i++) free_ast(then_body[i]);
            free(then_body);
            error_at(previous_token(), "Out of memory allocating else body");
            return NULL;
        }
        
        while (!check(TOKEN_END_IF) && !is_at_end()) {
            ASTNode* stmt = parse_statement();
            if (!stmt) {
                free_ast(condition);
                for (int i = 0; i < then_count; i++) free_ast(then_body[i]);
                free(then_body);
                for (int i = 0; i < else_count; i++) free_ast(else_body[i]);
                free(else_body);
                return NULL;
            }
            
            /* Skip empty statements */
            if (stmt->type == AST_EXPR_STMT && stmt->data.return_stmt.expression == NULL) {
                free_ast(stmt);
                continue;
            }
            
            /* Expand array if needed */
            if (else_count >= else_capacity) {
                else_capacity *= 2;
                ASTNode** new_else = realloc(else_body, sizeof(ASTNode*) * else_capacity);
                if (!new_else) {
                    free_ast(stmt);
                    free_ast(condition);
                    for (int i = 0; i < then_count; i++) free_ast(then_body[i]);
                    free(then_body);
                    for (int i = 0; i < else_count; i++) free_ast(else_body[i]);
                    free(else_body);
                    error_at(current_token(), "Out of memory expanding else body");
                    return NULL;
                }
                else_body = new_else;
            }
            
            else_body[else_count++] = stmt;
        }
    }
    
    if (!expect(TOKEN_END_IF, "Expected 'end_if'")) {
        free_ast(condition);
        for (int i = 0; i < then_count; i++) free_ast(then_body[i]);
        free(then_body);
        for (int i = 0; i < else_count; i++) free_ast(else_body[i]);
        free(else_body);
        return NULL;
    }
    
    skip_newlines();
    
    return create_if_node(condition, then_body, then_count, else_body, else_count,
                          if_token->line, if_token->column);
}

/* Parse while statement */
static ASTNode* parse_while_statement(void) {
    Token* while_token = advance();  /* WHILE */
    
    ASTNode* condition = parse_expression();
    if (!condition) return NULL;
    
    skip_newlines();
    
    /* Parse body */
    ASTNode** body = NULL;
    int body_count = 0;
    int body_capacity = 8;
    
    body = malloc(sizeof(ASTNode*) * body_capacity);
    if (!body) {
        free_ast(condition);
        error_at(while_token, "Out of memory allocating while body");
        return NULL;
    }
    
    while (!check(TOKEN_END_WHILE) && !is_at_end()) {
        ASTNode* stmt = parse_statement();
        if (!stmt) {
            free_ast(condition);
            for (int i = 0; i < body_count; i++) free_ast(body[i]);
            free(body);
            return NULL;
        }
        
        /* Skip empty statements */
        if (stmt->type == AST_EXPR_STMT && stmt->data.return_stmt.expression == NULL) {
            free_ast(stmt);
            continue;
        }
        
        /* Expand array if needed */
        if (body_count >= body_capacity) {
            body_capacity *= 2;
            ASTNode** new_body = realloc(body, sizeof(ASTNode*) * body_capacity);
            if (!new_body) {
                free_ast(stmt);
                free_ast(condition);
                for (int i = 0; i < body_count; i++) free_ast(body[i]);
                free(body);
                error_at(current_token(), "Out of memory expanding while body");
                return NULL;
            }
            body = new_body;
        }
        
        body[body_count++] = stmt;
    }
    
    if (!expect(TOKEN_END_WHILE, "Expected 'end_while'")) {
        free_ast(condition);
        for (int i = 0; i < body_count; i++) free_ast(body[i]);
        free(body);
        return NULL;
    }
    
    skip_newlines();
    
    return create_while_node(condition, body, body_count,
                             while_token->line, while_token->column);
}

/* Parse return statement */
static ASTNode* parse_return_statement(void) {
    Token* return_token = advance();  /* RETURN */
    
    ASTNode* expression = NULL;
    
    /* Optional return value */
    if (!check(TOKEN_NEWLINE)) {
        expression = parse_expression();
        if (!expression) return NULL;
    }
    
    if (!expect(TOKEN_NEWLINE, "Expected newline after return")) {
        free_ast(expression);
        return NULL;
    }
    
    return create_return_node(expression, return_token->line, return_token->column);
}

/* Parse expression (top-level) */
static ASTNode* parse_expression(void) {
    return parse_logical_or();
}

/* Parse logical OR: logical_and ("or" logical_and)* */
static ASTNode* parse_logical_or(void) {
    ASTNode* left = parse_logical_and();
    if (!left) return NULL;
    
    while (match(TOKEN_OR)) {
        Token* op_token = previous_token();
        ASTNode* right = parse_logical_and();
        if (!right) {
            free_ast(left);
            return NULL;
        }
        left = create_binary_op_node(TOKEN_OR, left, right,
                                      op_token->line, op_token->column);
    }
    
    return left;
}

/* Parse logical AND: equality ("and" equality)* */
static ASTNode* parse_logical_and(void) {
    ASTNode* left = parse_equality();
    if (!left) return NULL;
    
    while (match(TOKEN_AND)) {
        Token* op_token = previous_token();
        ASTNode* right = parse_equality();
        if (!right) {
            free_ast(left);
            return NULL;
        }
        left = create_binary_op_node(TOKEN_AND, left, right,
                                      op_token->line, op_token->column);
    }
    
    return left;
}

/* Parse equality: comparison (("==" | "!=") comparison)* */
static ASTNode* parse_equality(void) {
    ASTNode* left = parse_comparison();
    if (!left) return NULL;
    
    while (match(TOKEN_EQUAL_EQUAL) || match(TOKEN_NOT_EQUAL)) {
        Token* op_token = previous_token();
        ASTNode* right = parse_comparison();
        if (!right) {
            free_ast(left);
            return NULL;
        }
        left = create_binary_op_node(op_token->type, left, right,
                                      op_token->line, op_token->column);
    }
    
    return left;
}

/* Parse comparison: term (("<" | "<=" | ">" | ">=") term)* */
static ASTNode* parse_comparison(void) {
    ASTNode* left = parse_term();
    if (!left) return NULL;
    
    while (match(TOKEN_LESS) || match(TOKEN_LESS_EQUAL) ||
           match(TOKEN_GREATER) || match(TOKEN_GREATER_EQUAL)) {
        Token* op_token = previous_token();
        ASTNode* right = parse_term();
        if (!right) {
            free_ast(left);
            return NULL;
        }
        left = create_binary_op_node(op_token->type, left, right,
                                      op_token->line, op_token->column);
    }
    
    return left;
}

/* Parse term: factor (("+" | "-") factor)* */
static ASTNode* parse_term(void) {
    ASTNode* left = parse_factor();
    if (!left) return NULL;
    
    while (match(TOKEN_PLUS) || match(TOKEN_MINUS)) {
        Token* op_token = previous_token();
        ASTNode* right = parse_factor();
        if (!right) {
            free_ast(left);
            return NULL;
        }
        left = create_binary_op_node(op_token->type, left, right,
                                      op_token->line, op_token->column);
    }
    
    return left;
}

/* Parse factor: unary (("*" | "/" | "mod") unary)* */
static ASTNode* parse_factor(void) {
    ASTNode* left = parse_unary();
    if (!left) return NULL;
    
    while (match(TOKEN_STAR) || match(TOKEN_SLASH) || match(TOKEN_MOD)) {
        Token* op_token = previous_token();
        ASTNode* right = parse_unary();
        if (!right) {
            free_ast(left);
            return NULL;
        }
        left = create_binary_op_node(op_token->type, left, right,
                                      op_token->line, op_token->column);
    }
    
    return left;
}

/* Parse unary: ("not" | "-") unary | primary */
static ASTNode* parse_unary(void) {
    if (match(TOKEN_NOT) || match(TOKEN_MINUS)) {
        Token* op_token = previous_token();
        ASTNode* operand = parse_unary();
        if (!operand) return NULL;
        return create_unary_op_node(op_token->type, operand,
                                    op_token->line, op_token->column);
    }
    
    return parse_primary();
}

/* Parse primary: NUMBER | "true" | "false" | IDENT | call | "(" expression ")" */
static ASTNode* parse_primary(void) {
    /* Number literal */
    if (match(TOKEN_NUMBER)) {
        Token* tok = previous_token();
        return create_literal_node(TOKEN_NUMBER, tok->value.int_value,
                                   tok->line, tok->column);
    }
    
    /* Boolean literals */
    if (match(TOKEN_TRUE)) {
        Token* tok = previous_token();
        return create_literal_node(TOKEN_TRUE, 1, tok->line, tok->column);
    }
    
    if (match(TOKEN_FALSE)) {
        Token* tok = previous_token();
        return create_literal_node(TOKEN_FALSE, 0, tok->line, tok->column);
    }
    
    /* Identifier or function call */
    if (match(TOKEN_IDENTIFIER)) {
        Token* name_token = previous_token();
        
        /* Check for function call */
        if (check(TOKEN_LEFT_PAREN)) {
            return parse_call(name_token->lexeme, name_token->line, name_token->column);
        }
        
        /* Just an identifier */
        return create_identifier_node(name_token->lexeme, name_token->line, name_token->column);
    }
    
    /* Grouped expression */
    if (match(TOKEN_LEFT_PAREN)) {
        ASTNode* expr = parse_expression();
        if (!expr) return NULL;
        
        if (!expect(TOKEN_RIGHT_PAREN, "Expected ')' after expression")) {
            free_ast(expr);
            return NULL;
        }
        
        return expr;
    }
    
    /* Error: unexpected token */
    Token* tok = current_token();
    snprintf(parser.error_message, sizeof(parser.error_message),
             "Unexpected token in expression at line %d, column %d: '%.*s'",
             tok->line, tok->column, tok->lexeme_length, tok->lexeme);
    parser.has_error = 1;
    return NULL;
}

/* Parse function call: IDENT "(" args? ")" */
static ASTNode* parse_call(const char* name, int line, int column) {
    if (!expect(TOKEN_LEFT_PAREN, "Expected '(' for function call")) {
        return NULL;
    }
    
    ASTNode** arguments = NULL;
    int arg_count = 0;
    int arg_capacity = 4;
    
    /* Parse arguments */
    if (!check(TOKEN_RIGHT_PAREN)) {
        arguments = malloc(sizeof(ASTNode*) * arg_capacity);
        if (!arguments) {
            error_at(current_token(), "Out of memory allocating arguments");
            return NULL;
        }
        
        do {
            ASTNode* arg = parse_expression();
            if (!arg) {
                for (int i = 0; i < arg_count; i++) free_ast(arguments[i]);
                free(arguments);
                return NULL;
            }
            
            /* Expand array if needed */
            if (arg_count >= arg_capacity) {
                arg_capacity *= 2;
                ASTNode** new_args = realloc(arguments, sizeof(ASTNode*) * arg_capacity);
                if (!new_args) {
                    free_ast(arg);
                    for (int i = 0; i < arg_count; i++) free_ast(arguments[i]);
                    free(arguments);
                    error_at(current_token(), "Out of memory expanding arguments");
                    return NULL;
                }
                arguments = new_args;
            }
            
            arguments[arg_count++] = arg;
            
        } while (match(TOKEN_SEMICOLON));
    }
    
    if (!expect(TOKEN_RIGHT_PAREN, "Expected ')' after arguments")) {
        for (int i = 0; i < arg_count; i++) free_ast(arguments[i]);
        free(arguments);
        return NULL;
    }
    
    return create_call_node(name, arguments, arg_count, line, column);
}

/* ============================================================================
 * PUBLIC API
 * ============================================================================ */

/* Parse source code */
ASTNode* parse(const char* source) {
    /* Initialize parser state */
    parser.current = 0;
    parser.has_error = 0;
    parser.error_message[0] = '\0';
    
    /* Tokenize source (peer call to lexer) */
    int token_count;
    Token* tokens = tokenize(source, &token_count);
    if (!tokens) {
        snprintf(parser.error_message, sizeof(parser.error_message),
                 "Lexer failed to tokenize source");
        return NULL;
    }
    
    /* Set parser state */
    parser.tokens = tokens;
    parser.count = token_count;
    
    /* Parse program */
    ASTNode* ast = parse_program();
    
    /* Clean up tokens */
    free_tokens(tokens, token_count);
    
    return ast;
}

/* Parse token array directly */
ASTNode* parse_tokens(Token* tokens, int count) {
    /* Initialize parser state */
    parser.tokens = tokens;
    parser.count = count;
    parser.current = 0;
    parser.has_error = 0;
    parser.error_message[0] = '\0';
    
    /* Parse program */
    return parse_program();
}

/* Get last error message */
const char* get_parse_error(void) {
    if (parser.has_error) {
        return parser.error_message;
    }
    return NULL;
}
