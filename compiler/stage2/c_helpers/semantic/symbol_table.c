/* MELP Stage 2 - Symbol Table Implementation
 * Generated by: YZ_04 (Semantic Analysis Specialist)
 * Date: 15 Ocak 2026
 * Phase: 4.0 - Semantic Analysis Implementation
 */

#define _POSIX_C_SOURCE 200809L
#include "symbol_table.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>
#include <ctype.h>

/* Initial capacity for symbol array */
#define INITIAL_CAPACITY 16

/* ============================================================================
 * INTERNAL HELPERS
 * ============================================================================ */

/* Helper: Grow symbol array capacity */
static bool grow_symbol_table(SymbolTable* table) {
    int new_capacity = table->capacity * 2;
    Symbol** new_symbols = (Symbol**)realloc(table->symbols,
                                             new_capacity * sizeof(Symbol*));
    if (!new_symbols) {
        return false;  /* Allocation failure */
    }
    
    table->symbols = new_symbols;
    table->capacity = new_capacity;
    return true;
}

/* Helper: Create symbol entry */
static Symbol* create_symbol(const char* name, SymbolKind kind,
                            ASTNode* type_node, int line, int column) {
    Symbol* sym = (Symbol*)malloc(sizeof(Symbol));
    if (!sym) {
        return NULL;
    }
    
    /* Copy name string (symbol owns the copy) */
    /* WORKAROUND: Parser bug - name may not be null-terminated properly */
    /* Extract only valid identifier characters */
    size_t len = 0;
    while (name[len] && (isalnum(name[len]) || name[len] == '_')) {
        len++;
    }
    sym->name = (char*)malloc(len + 1);
    if (!sym->name) {
        free(sym);
        return NULL;
    }
    strncpy(sym->name, name, len);
    sym->name[len] = '\0';
    
    sym->kind = kind;
    sym->type_node = type_node;  /* Reference, not copy */
    sym->line = line;
    sym->column = column;
    sym->param_count = 0;
    sym->parameters = NULL;
    
    return sym;
}

/* Helper: Free symbol entry */
static void free_symbol(Symbol* sym) {
    if (!sym) return;
    
    free(sym->name);
    
    /* Free parameter array (if function) */
    if (sym->kind == SYMBOL_FUNCTION && sym->parameters) {
        /* Parameters are also in symbol table, so don't free them here */
        free(sym->parameters);
    }
    
    free(sym);
}

/* ============================================================================
 * SYMBOL TABLE API IMPLEMENTATION
 * ============================================================================ */

SymbolTable* create_symbol_table(SymbolTable* parent) {
    SymbolTable* table = (SymbolTable*)malloc(sizeof(SymbolTable));
    if (!table) {
        return NULL;
    }
    
    table->symbols = (Symbol**)malloc(INITIAL_CAPACITY * sizeof(Symbol*));
    if (!table->symbols) {
        free(table);
        return NULL;
    }
    
    table->count = 0;
    table->capacity = INITIAL_CAPACITY;
    table->parent = parent;
    
    return table;
}

void free_symbol_table(SymbolTable* table) {
    if (!table) return;
    
    /* Free all symbols */
    for (int i = 0; i < table->count; i++) {
        free_symbol(table->symbols[i]);
    }
    
    /* Free symbol array */
    free(table->symbols);
    
    /* Free table structure */
    free(table);
    
    /* Note: Parent scope is NOT freed (caller's responsibility) */
}

Symbol* add_symbol(SymbolTable* table, const char* name, SymbolKind kind,
                   ASTNode* type_node, int line, int column) {
    if (!table || !name) {
        return NULL;
    }
    
    /* Check for redeclaration in CURRENT scope only */
    Symbol* existing = lookup_symbol_local(table, name);
    if (existing) {
        /* Symbol already declared in this scope */
        return NULL;
    }
    
    /* Grow array if needed */
    if (table->count >= table->capacity) {
        if (!grow_symbol_table(table)) {
            return NULL;  /* Allocation failure */
        }
    }
    
    /* Create new symbol */
    Symbol* sym = create_symbol(name, kind, type_node, line, column);
    if (!sym) {
        return NULL;
    }
    
    /* Add to table */
    table->symbols[table->count++] = sym;
    
    return sym;
}

Symbol* lookup_symbol(SymbolTable* table, const char* name) {
    if (!table || !name) {
        return NULL;
    }
    
    /* Search current scope */
    Symbol* sym = lookup_symbol_local(table, name);
    if (sym) {
        return sym;
    }
    
    /* Search parent scope recursively */
    if (table->parent) {
        return lookup_symbol(table->parent, name);
    }
    
    /* Not found in any scope */
    return NULL;
}

Symbol* lookup_symbol_local(SymbolTable* table, const char* name) {
    if (!table || !name) {
        return NULL;
    }
    
    /* WORKAROUND: Extract clean identifier from potentially corrupt name */
    char clean_name[256];
    size_t len = 0;
    while (name[len] && len < 255 && (isalnum(name[len]) || name[len] == '_')) {
        clean_name[len] = name[len];
        len++;
    }
    clean_name[len] = '\0';
    
    /* Linear search (sufficient for PMLP0/PMLP1 scale) */
    for (int i = 0; i < table->count; i++) {
        if (strcmp(table->symbols[i]->name, clean_name) == 0) {
            return table->symbols[i];
        }
    }
    
    return NULL;
}

/* ============================================================================
 * UTILITY FUNCTIONS
 * ============================================================================ */

const char* symbol_kind_name(SymbolKind kind) {
    switch (kind) {
        case SYMBOL_VARIABLE:  return "variable";
        case SYMBOL_FUNCTION:  return "function";
        case SYMBOL_PARAMETER: return "parameter";
        default:               return "unknown";
    }
}

void print_symbol_table(SymbolTable* table, int indent) {
    if (!table) return;
    
    printf("%*sSymbolTable (%d symbols):\n", indent * 2, "", table->count);
    for (int i = 0; i < table->count; i++) {
        Symbol* sym = table->symbols[i];
        printf("%*s- %s '%s' at %d:%d\n",
               (indent + 1) * 2, "",
               symbol_kind_name(sym->kind),
               sym->name,
               sym->line,
               sym->column);
        
        if (sym->kind == SYMBOL_FUNCTION && sym->param_count > 0) {
            printf("%*s  Parameters: %d\n",
                   (indent + 1) * 2, "",
                   sym->param_count);
        }
    }
}
