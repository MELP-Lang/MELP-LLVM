#ifndef TYPE_CHECKER_H
#define TYPE_CHECKER_H

/* MELP Stage 2 - Type Checker
 * Generated by: YZ_04 (Semantic Analysis Specialist)
 * Date: 15 Ocak 2026
 * Phase: 4.0 - Semantic Analysis Implementation
 * 
 * This header defines the type system and type checking functions.
 * 
 * Design Principles:
 * - Simple type representation (numeric, boolean, void)
 * - Type compatibility checking
 * - Type inference from expressions
 * - Clear error propagation
 */

#include "../common/ast.h"
#include "symbol_table.h"
#include <stdbool.h>

/* ============================================================================
 * TYPE SYSTEM
 * ============================================================================ */

/* Type Classification
 * 
 * TYPE_INT     - 64-bit signed integer (PMLP: "numeric")
 * TYPE_BOOL    - Boolean true/false (PMLP: "boolean")
 * TYPE_VOID    - No value (function return only)
 * TYPE_ERROR   - Error sentinel (for error propagation)
 * TYPE_UNKNOWN - Unresolved type (should not appear in final analysis)
 */
typedef enum {
    TYPE_INT,
    TYPE_BOOL,
    TYPE_VOID,
    TYPE_ERROR,
    TYPE_UNKNOWN
} TypeKind;

/* Type Representation
 * 
 * Simple type structure for PMLP0/PMLP1.
 * Future extensions: arrays, structs, function types.
 */
typedef struct Type {
    TypeKind kind;
    /* Future fields: array element type, struct fields, etc. */
} Type;

/* ============================================================================
 * TYPE CONSTRUCTION
 * ============================================================================ */

/* Create type instances (returns static singletons for efficiency) */
Type* create_int_type(void);
Type* create_bool_type(void);
Type* create_void_type(void);
Type* create_error_type(void);
Type* create_unknown_type(void);

/* Convert AST type node to Type
 * 
 * Parameters:
 *   ast_type - AST_TYPE node (TOKEN_NUMERIC or TOKEN_BOOLEAN)
 * 
 * Returns:
 *   Type* - Corresponding type
 *   TYPE_UNKNOWN if ast_type is NULL or invalid
 */
Type* ast_type_to_type(ASTNode* ast_type);

/* ============================================================================
 * TYPE CHECKING API
 * ============================================================================ */

/* Get type of expression
 * 
 * Parameters:
 *   expr  - Expression AST node
 *   table - Symbol table (for variable lookup)
 * 
 * Returns:
 *   Type* - Expression type
 *   TYPE_ERROR if expression is invalid (undefined variable, type mismatch, etc.)
 * 
 * Behavior:
 *   - Literals: 42 → TYPE_INT, true → TYPE_BOOL
 *   - Variables: Lookup in symbol table
 *   - Binary ops: Check operand types, compute result type
 *   - Unary ops: Check operand type, compute result type
 *   - Function calls: Check argument types, return function's return type
 * 
 * Note: Does NOT report errors (caller's responsibility)
 */
Type* get_expression_type(ASTNode* expr, SymbolTable* table);

/* Check if types are compatible
 * 
 * Parameters:
 *   t1, t2 - Types to compare
 * 
 * Returns:
 *   true if types are compatible (equal or compatible for assignment)
 *   false otherwise
 * 
 * Compatibility rules:
 *   - TYPE_INT == TYPE_INT
 *   - TYPE_BOOL == TYPE_BOOL
 *   - TYPE_VOID == TYPE_VOID
 *   - TYPE_ERROR is compatible with anything (error propagation)
 *   - All other combinations are incompatible
 */
bool types_compatible(Type* t1, Type* t2);

/* Check if type is numeric */
bool is_numeric_type(Type* t);

/* Check if type is boolean */
bool is_boolean_type(Type* t);

/* Check if type is void */
bool is_void_type(Type* t);

/* Check if type is error */
bool is_error_type(Type* t);

/* ============================================================================
 * TYPE UTILITIES
 * ============================================================================ */

/* Get human-readable type name */
const char* type_to_string(Type* t);

/* Get expected type for binary operator
 * 
 * Parameters:
 *   op - Binary operator token type
 *   result_type - Output: result type of operation (can be NULL)
 * 
 * Returns:
 *   Type* - Expected operand type
 *   NULL if operator is invalid
 * 
 * Operator Type Rules:
 *   - Arithmetic (+, -, *, /, mod): int × int → int
 *   - Comparison (<, >, <=, >=):    int × int → bool
 *   - Equality (==, !=):            int × int → bool OR bool × bool → bool
 *   - Logical (and, or):            bool × bool → bool
 */
Type* get_binary_op_expected_type(TokenType op, Type** result_type);

/* Get expected type for unary operator
 * 
 * Parameters:
 *   op - Unary operator token type
 *   result_type - Output: result type of operation (can be NULL)
 * 
 * Returns:
 *   Type* - Expected operand type
 *   NULL if operator is invalid
 * 
 * Operator Type Rules:
 *   - Negation (-): int → int
 *   - Logical not (not): bool → bool
 */
Type* get_unary_op_expected_type(TokenType op, Type** result_type);

#endif /* TYPE_CHECKER_H */
