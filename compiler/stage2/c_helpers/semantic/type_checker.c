/* MELP Stage 2 - Type Checker Implementation
 * Generated by: YZ_04 (Semantic Analysis Specialist)
 * Date: 15 Ocak 2026
 * Phase: 4.0 - Semantic Analysis Implementation
 */

#include "type_checker.h"
#include <stdlib.h>
#include <string.h>

/* ============================================================================
 * TYPE SINGLETON INSTANCES (for efficiency)
 * ============================================================================ */

static Type type_int = { TYPE_INT };
static Type type_bool = { TYPE_BOOL };
static Type type_void = { TYPE_VOID };
static Type type_error = { TYPE_ERROR };
static Type type_unknown = { TYPE_UNKNOWN };

/* ============================================================================
 * TYPE CONSTRUCTION
 * ============================================================================ */

Type* create_int_type(void) {
    return &type_int;
}

Type* create_bool_type(void) {
    return &type_bool;
}

Type* create_void_type(void) {
    return &type_void;
}

Type* create_error_type(void) {
    return &type_error;
}

Type* create_unknown_type(void) {
    return &type_unknown;
}

Type* ast_type_to_type(ASTNode* ast_type) {
    if (!ast_type || ast_type->type != AST_TYPE) {
        return create_unknown_type();
    }
    
    switch (ast_type->data.type.type_token) {
        case TOKEN_NUMERIC:
            return create_int_type();
        case TOKEN_BOOLEAN:
            return create_bool_type();
        default:
            return create_unknown_type();
    }
}

/* ============================================================================
 * TYPE CHECKING API
 * ============================================================================ */

Type* get_expression_type(ASTNode* expr, SymbolTable* table) {
    if (!expr) {
        return create_error_type();
    }
    
    switch (expr->type) {
        case AST_LITERAL: {
            /* Literal types are directly determined by token type */
            switch (expr->data.literal.literal_type) {
                case TOKEN_NUMBER:
                    return create_int_type();
                case TOKEN_TRUE:
                case TOKEN_FALSE:
                    return create_bool_type();
                default:
                    return create_error_type();
            }
        }
        
        case AST_IDENTIFIER: {
            /* Lookup variable in symbol table */
            Symbol* sym = lookup_symbol(table, expr->data.identifier.name);
            if (!sym) {
                /* Undefined variable - return error type */
                return create_error_type();
            }
            
            /* Return type from symbol's type node */
            return ast_type_to_type(sym->type_node);
        }
        
        case AST_BINARY_OP: {
            /* Get operand types */
            Type* left_type = get_expression_type(
                expr->data.binary_op.left, table);
            Type* right_type = get_expression_type(
                expr->data.binary_op.right, table);
            
            /* Propagate error */
            if (is_error_type(left_type) || is_error_type(right_type)) {
                return create_error_type();
            }
            
            /* Get expected type and result type for operator */
            Type* result_type = NULL;
            Type* expected_type = get_binary_op_expected_type(
                expr->data.binary_op.op, &result_type);
            
            if (!expected_type || !result_type) {
                /* Invalid operator */
                return create_error_type();
            }
            
            /* Special case: equality operators accept int OR bool */
            if (expr->data.binary_op.op == TOKEN_EQUAL_EQUAL ||
                expr->data.binary_op.op == TOKEN_NOT_EQUAL) {
                /* Both operands must be same type (int or bool) */
                if (types_compatible(left_type, right_type)) {
                    if (is_numeric_type(left_type) || is_boolean_type(left_type)) {
                        return create_bool_type();
                    }
                }
                return create_error_type();
            }
            
            /* Check operand types match expected type */
            if (!types_compatible(left_type, expected_type) ||
                !types_compatible(right_type, expected_type)) {
                return create_error_type();
            }
            
            return result_type;
        }
        
        case AST_UNARY_OP: {
            /* Get operand type */
            Type* operand_type = get_expression_type(
                expr->data.unary_op.operand, table);
            
            /* Propagate error */
            if (is_error_type(operand_type)) {
                return create_error_type();
            }
            
            /* Get expected type and result type for operator */
            Type* result_type = NULL;
            Type* expected_type = get_unary_op_expected_type(
                expr->data.unary_op.op, &result_type);
            
            if (!expected_type || !result_type) {
                /* Invalid operator */
                return create_error_type();
            }
            
            /* Check operand type matches expected type */
            if (!types_compatible(operand_type, expected_type)) {
                return create_error_type();
            }
            
            return result_type;
        }
        
        case AST_FUNCTION_CALL: {
            /* Lookup function in symbol table */
            Symbol* func = lookup_symbol(table, expr->data.call.name);
            if (!func || func->kind != SYMBOL_FUNCTION) {
                /* Undefined function - return error type */
                return create_error_type();
            }
            
            /* Return function's return type */
            return ast_type_to_type(func->type_node);
        }
        
        default:
            /* Non-expression node */
            return create_error_type();
    }
}

bool types_compatible(Type* t1, Type* t2) {
    if (!t1 || !t2) {
        return false;
    }
    
    /* Error type is compatible with anything (for error propagation) */
    if (t1->kind == TYPE_ERROR || t2->kind == TYPE_ERROR) {
        return true;
    }
    
    /* Otherwise, types must be exactly equal */
    return t1->kind == t2->kind;
}

bool is_numeric_type(Type* t) {
    return t && t->kind == TYPE_INT;
}

bool is_boolean_type(Type* t) {
    return t && t->kind == TYPE_BOOL;
}

bool is_void_type(Type* t) {
    return t && t->kind == TYPE_VOID;
}

bool is_error_type(Type* t) {
    return t && t->kind == TYPE_ERROR;
}

/* ============================================================================
 * TYPE UTILITIES
 * ============================================================================ */

const char* type_to_string(Type* t) {
    if (!t) {
        return "null";
    }
    
    switch (t->kind) {
        case TYPE_INT:     return "numeric";
        case TYPE_BOOL:    return "boolean";
        case TYPE_VOID:    return "void";
        case TYPE_ERROR:   return "error";
        case TYPE_UNKNOWN: return "unknown";
        default:           return "invalid";
    }
}

Type* get_binary_op_expected_type(TokenType op, Type** result_type) {
    switch (op) {
        /* Arithmetic: int × int → int */
        case TOKEN_PLUS:
        case TOKEN_MINUS:
        case TOKEN_STAR:
        case TOKEN_SLASH:
        case TOKEN_MOD:
            if (result_type) *result_type = create_int_type();
            return create_int_type();
        
        /* Comparison: int × int → bool */
        case TOKEN_LESS:
        case TOKEN_LESS_EQUAL:
        case TOKEN_GREATER:
        case TOKEN_GREATER_EQUAL:
            if (result_type) *result_type = create_bool_type();
            return create_int_type();
        
        /* Equality: handled specially in get_expression_type */
        case TOKEN_EQUAL_EQUAL:
        case TOKEN_NOT_EQUAL:
            if (result_type) *result_type = create_bool_type();
            return NULL;  /* Special case - accepts int OR bool */
        
        /* Logical: bool × bool → bool */
        case TOKEN_AND:
        case TOKEN_OR:
            if (result_type) *result_type = create_bool_type();
            return create_bool_type();
        
        default:
            return NULL;  /* Invalid operator */
    }
}

Type* get_unary_op_expected_type(TokenType op, Type** result_type) {
    switch (op) {
        /* Negation: int → int */
        case TOKEN_MINUS:
            if (result_type) *result_type = create_int_type();
            return create_int_type();
        
        /* Logical not: bool → bool */
        case TOKEN_NOT:
            if (result_type) *result_type = create_bool_type();
            return create_bool_type();
        
        default:
            return NULL;  /* Invalid operator */
    }
}
