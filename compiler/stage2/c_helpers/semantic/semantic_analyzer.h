#ifndef SEMANTIC_ANALYZER_H
#define SEMANTIC_ANALYZER_H

/* MELP Stage 2 - Semantic Analyzer
 * Generated by: YZ_04 (Semantic Analysis Specialist)
 * Date: 15 Ocak 2026
 * Phase: 4.0 - Semantic Analysis Implementation
 * 
 * This header defines the semantic analysis interface.
 * 
 * Design Principles (AUTONOMOUS):
 * - Peer to parser: Imports parser_impl.h, calls parse()
 * - Single responsibility: ONLY semantic analysis
 * - Symbol table management: Variable/function tracking
 * - Type checking: Operator validation, type compatibility
 * - Error reporting: Clear messages with location info
 */

#include "../parser/parser_impl.h"
#include "symbol_table.h"
#include "type_checker.h"
#include <stdbool.h>

/* ============================================================================
 * MAIN API
 * ============================================================================ */

/* Analyze program semantics
 * 
 * Parameters:
 *   ast - Root AST node (AST_PROGRAM)
 * 
 * Returns:
 *   true if program is semantically valid
 *   false if semantic errors detected
 * 
 * Behavior:
 *   1. Creates global symbol table
 *   2. First pass: Collect all function declarations
 *   3. Second pass: Analyze function bodies
 *   4. Checks:
 *      - Undefined variables/functions
 *      - Redeclaration errors
 *      - Type mismatches (operators, assignments, returns)
 *      - Function call validation (arg count, arg types)
 *      - Control flow type checking (if/while conditions)
 * 
 * Error Handling:
 *   - First error is recorded in error_message
 *   - Analysis stops on first error (fail-fast)
 *   - Error includes line/column and descriptive message
 * 
 * Example:
 *   ASTNode* ast = parse(source);
 *   if (ast && analyze_program(ast)) {
 *       // Program is valid, proceed to codegen
 *   } else {
 *       fprintf(stderr, "Semantic error: %s\n", get_semantic_error());
 *   }
 *   free_ast(ast);
 */
bool analyze_program(ASTNode* ast);

/* Analyze program from source (convenience function)
 * 
 * Parameters:
 *   source - Source code string
 * 
 * Returns:
 *   true if program is semantically valid
 *   false if parse error or semantic error
 * 
 * Behavior:
 *   1. Calls parse(source) - PEER TO PEER!
 *   2. If parse succeeds, calls analyze_program()
 *   3. Cleans up AST
 * 
 * Example:
 *   if (analyze_program_from_source(source)) {
 *       printf("Program is valid!\n");
 *   } else {
 *       fprintf(stderr, "Error: %s\n", get_semantic_error());
 *   }
 */
bool analyze_program_from_source(const char* source);

/* ============================================================================
 * ERROR REPORTING
 * ============================================================================ */

/* Get last semantic error message
 * 
 * Returns:
 *   const char* - Error message (static buffer)
 *   NULL if no error
 * 
 * Example:
 *   if (!analyze_program(ast)) {
 *       const char* err = get_semantic_error();
 *       if (err) {
 *           fprintf(stderr, "Semantic error: %s\n", err);
 *       }
 *   }
 */
const char* get_semantic_error(void);

/* Get number of semantic errors detected
 * 
 * Returns:
 *   int - Error count (currently always 0 or 1, fail-fast mode)
 */
int get_semantic_error_count(void);

#endif /* SEMANTIC_ANALYZER_H */
