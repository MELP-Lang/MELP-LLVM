/* MELP Stage 2 - Semantic Analyzer Test Suite
 * Generated by: YZ_04 (Semantic Analysis Specialist)
 * Date: 15 Ocak 2026
 * Phase: 4.0 - Semantic Analysis Implementation
 * 
 * Comprehensive test suite with >20 test cases covering:
 * - Symbol table (declaration, lookup, scopes, redeclaration)
 * - Type checking (binary ops, unary ops, assignments)
 * - Error detection (undefined vars, type mismatches)
 * - Function validation (params, return types, calls)
 * - Control flow (if/while conditions)
 * - Integration (complex programs)
 */

#include "semantic_analyzer.h"
#include <stdio.h>
#include <string.h>
#include <assert.h>

/* ============================================================================
 * TEST FRAMEWORK
 * ============================================================================ */

static int g_test_count = 0;
static int g_test_passed = 0;
static int g_test_failed = 0;

#define TEST(name) \
    do { \
        g_test_count++; \
        printf("Running %s... ", name); \
        fflush(stdout); \
    } while(0)

#define PASS() \
    do { \
        printf("‚úÖ PASSED\n"); \
        g_test_passed++; \
    } while(0)

#define FAIL(msg) \
    do { \
        printf("‚ùå FAILED: %s\n", msg); \
        g_test_failed++; \
    } while(0)

#define ASSERT_TRUE(cond, msg) \
    do { \
        if (!(cond)) { \
            FAIL(msg); \
            return; \
        } \
    } while(0)

#define ASSERT_FALSE(cond, msg) \
    do { \
        if (cond) { \
            FAIL(msg); \
            return; \
        } \
    } while(0)

#define ASSERT_ERROR_CONTAINS(substr) \
    do { \
        const char* err = get_semantic_error(); \
        if (!err || strstr(err, substr) == NULL) { \
            char buf[256]; \
            snprintf(buf, sizeof(buf), "Expected error containing '%s', got: %s", \
                    substr, err ? err : "NULL"); \
            FAIL(buf); \
            return; \
        } \
    } while(0)

/* ============================================================================
 * HAPPY PATH TESTS (Valid Programs)
 * ============================================================================ */

void test_simple_function(void) {
    TEST("test_simple_function");
    
    const char* source =
        "function main() as numeric\n"
        "  return 42\n"
        "end_function\n";
    
    bool result = analyze_program_from_source(source);
    ASSERT_TRUE(result, "Valid program should pass");
    PASS();
}

void test_variable_declaration(void) {
    TEST("test_variable_declaration");
    
    const char* source =
        "function main() as numeric\n"
        "  numeric x\n"
        "  return x\n"
        "end_function\n";
    
    bool result = analyze_program_from_source(source);
    ASSERT_TRUE(result, "Variable declaration should work");
    PASS();
}

void test_variable_initialization(void) {
    TEST("test_variable_initialization");
    
    const char* source =
        "function main() as numeric\n"
        "  numeric x = 10\n"
        "  return x\n"
        "end_function\n";
    
    bool result = analyze_program_from_source(source);
    ASSERT_TRUE(result, "Variable initialization should work");
    PASS();
}

void test_arithmetic_operations(void) {
    TEST("test_arithmetic_operations");
    
    const char* source =
        "function main() as numeric\n"
        "  numeric a = 10\n"
        "  numeric b = 20\n"
        "  numeric c = a + b\n"
        "  numeric d = a - b\n"
        "  numeric e = a * b\n"
        "  numeric f = a / b\n"
        "  numeric g = a mod b\n"
        "  return c\n"
        "end_function\n";
    
    bool result = analyze_program_from_source(source);
    ASSERT_TRUE(result, "Arithmetic operations should work");
    PASS();
}

void test_comparison_operations(void) {
    TEST("test_comparison_operations");
    
    const char* source =
        "function main() as boolean\n"
        "  numeric a = 10\n"
        "  numeric b = 20\n"
        "  boolean c = a < b\n"
        "  boolean d = a > b\n"
        "  boolean e = a <= b\n"
        "  boolean f = a >= b\n"
        "  return c\n"
        "end_function\n";
    
    bool result = analyze_program_from_source(source);
    ASSERT_TRUE(result, "Comparison operations should work");
    PASS();
}

void test_logical_operations(void) {
    TEST("test_logical_operations");
    
    const char* source =
        "function main() as boolean\n"
        "  boolean a = true\n"
        "  boolean b = false\n"
        "  boolean c = a and b\n"
        "  boolean d = a or b\n"
        "  boolean e = not a\n"
        "  return c\n"
        "end_function\n";
    
    bool result = analyze_program_from_source(source);
    ASSERT_TRUE(result, "Logical operations should work");
    PASS();
}

void test_if_statement(void) {
    TEST("test_if_statement");
    
    const char* source =
        "function main() as numeric\n"
        "  numeric x = 10\n"
        "  if x > 5 then\n"
        "    x = 20\n"
        "  end_if\n"
        "  return x\n"
        "end_function\n";
    
    bool result = analyze_program_from_source(source);
    ASSERT_TRUE(result, "If statement should work");
    PASS();
}

void test_while_statement(void) {
    TEST("test_while_statement");
    
    const char* source =
        "function main() as numeric\n"
        "  numeric x = 0\n"
        "  while x < 10\n"
        "    x = x + 1\n"
        "  end_while\n"
        "  return x\n"
        "end_function\n";
    
    bool result = analyze_program_from_source(source);
    ASSERT_TRUE(result, "While statement should work");
    PASS();
}

void test_function_with_parameters(void) {
    TEST("test_function_with_parameters");
    
    const char* source =
        "function add(numeric a; numeric b) as numeric\n"
        "  return a + b\n"
        "end_function\n"
        "function main() as numeric\n"
        "  return add(10; 20)\n"
        "end_function\n";
    
    bool result = analyze_program_from_source(source);
    ASSERT_TRUE(result, "Function with parameters should work");
    PASS();
}

void test_function_call(void) {
    TEST("test_function_call");
    
    const char* source =
        "function helper() as numeric\n"
        "  return 42\n"
        "end_function\n"
        "function main() as numeric\n"
        "  numeric x = helper()\n"
        "  return x\n"
        "end_function\n";
    
    bool result = analyze_program_from_source(source);
    ASSERT_TRUE(result, "Function call should work");
    PASS();
}

/* ============================================================================
 * ERROR DETECTION TESTS
 * ============================================================================ */

void test_undefined_variable(void) {
    TEST("test_undefined_variable");
    
    const char* source =
        "function main() as numeric\n"
        "  return x\n"
        "end_function\n";
    
    bool result = analyze_program_from_source(source);
    ASSERT_FALSE(result, "Undefined variable should fail");
    ASSERT_ERROR_CONTAINS("undefined");
    PASS();
}

void test_undefined_function(void) {
    TEST("test_undefined_function");
    
    const char* source =
        "function main() as numeric\n"
        "  return foo()\n"
        "end_function\n";
    
    bool result = analyze_program_from_source(source);
    ASSERT_FALSE(result, "Undefined function should fail");
    ASSERT_ERROR_CONTAINS("undefined");
    PASS();
}

void test_variable_redeclaration(void) {
    TEST("test_variable_redeclaration");
    
    const char* source =
        "function main() as numeric\n"
        "  numeric x = 5\n"
        "  numeric x = 10\n"
        "  return x\n"
        "end_function\n";
    
    bool result = analyze_program_from_source(source);
    ASSERT_FALSE(result, "Variable redeclaration should fail");
    ASSERT_ERROR_CONTAINS("redeclaration");
    PASS();
}

void test_function_redeclaration(void) {
    TEST("test_function_redeclaration");
    
    const char* source =
        "function foo() as numeric\n"
        "  return 1\n"
        "end_function\n"
        "function foo() as numeric\n"
        "  return 2\n"
        "end_function\n";
    
    bool result = analyze_program_from_source(source);
    ASSERT_FALSE(result, "Function redeclaration should fail");
    ASSERT_ERROR_CONTAINS("redeclaration");
    PASS();
}

void test_type_mismatch_binary_op(void) {
    TEST("test_type_mismatch_binary_op");
    
    const char* source =
        "function main() as numeric\n"
        "  numeric x = 5 + true\n"
        "  return x\n"
        "end_function\n";
    
    bool result = analyze_program_from_source(source);
    ASSERT_FALSE(result, "Type mismatch in binary op should fail");
    ASSERT_ERROR_CONTAINS("operator");
    PASS();
}

void test_type_mismatch_assignment(void) {
    TEST("test_type_mismatch_assignment");
    
    const char* source =
        "function main() as numeric\n"
        "  numeric x = 5\n"
        "  x = true\n"
        "  return x\n"
        "end_function\n";
    
    bool result = analyze_program_from_source(source);
    ASSERT_FALSE(result, "Type mismatch in assignment should fail");
    ASSERT_ERROR_CONTAINS("assign");
    PASS();
}

void test_type_mismatch_initialization(void) {
    TEST("test_type_mismatch_initialization");
    
    const char* source =
        "function main() as numeric\n"
        "  numeric x = true\n"
        "  return x\n"
        "end_function\n";
    
    bool result = analyze_program_from_source(source);
    ASSERT_FALSE(result, "Type mismatch in initialization should fail");
    ASSERT_ERROR_CONTAINS("initialize");
    PASS();
}

void test_type_mismatch_return(void) {
    TEST("test_type_mismatch_return");
    
    const char* source =
        "function main() as numeric\n"
        "  return true\n"
        "end_function\n";
    
    bool result = analyze_program_from_source(source);
    ASSERT_FALSE(result, "Type mismatch in return should fail");
    ASSERT_ERROR_CONTAINS("return");
    PASS();
}

void test_if_condition_not_boolean(void) {
    TEST("test_if_condition_not_boolean");
    
    const char* source =
        "function main() as numeric\n"
        "  if 42 then\n"
        "    return 1\n"
        "  end_if\n"
        "  return 0\n"
        "end_function\n";
    
    bool result = analyze_program_from_source(source);
    ASSERT_FALSE(result, "Non-boolean if condition should fail");
    ASSERT_ERROR_CONTAINS("condition");
    PASS();
}

void test_while_condition_not_boolean(void) {
    TEST("test_while_condition_not_boolean");
    
    const char* source =
        "function main() as numeric\n"
        "  numeric x = 0\n"
        "  while 10\n"
        "    x = x + 1\n"
        "  end_while\n"
        "  return x\n"
        "end_function\n";
    
    bool result = analyze_program_from_source(source);
    ASSERT_FALSE(result, "Non-boolean while condition should fail");
    ASSERT_ERROR_CONTAINS("condition");
    PASS();
}

void test_function_call_wrong_arg_count(void) {
    TEST("test_function_call_wrong_arg_count");
    
    const char* source =
        "function add(numeric a; numeric b) as numeric\n"
        "  return a + b\n"
        "end_function\n"
        "function main() as numeric\n"
        "  return add(10)\n"
        "end_function\n";
    
    bool result = analyze_program_from_source(source);
    ASSERT_FALSE(result, "Wrong argument count should fail");
    ASSERT_ERROR_CONTAINS("argument");
    PASS();
}

void test_function_call_wrong_arg_type(void) {
    TEST("test_function_call_wrong_arg_type");
    
    const char* source =
        "function add(numeric a; numeric b) as numeric\n"
        "  return a + b\n"
        "end_function\n"
        "function main() as numeric\n"
        "  return add(10; true)\n"
        "end_function\n";
    
    bool result = analyze_program_from_source(source);
    ASSERT_FALSE(result, "Wrong argument type should fail");
    ASSERT_ERROR_CONTAINS("argument");
    PASS();
}

void test_unary_op_wrong_type(void) {
    TEST("test_unary_op_wrong_type");
    
    const char* source =
        "function main() as numeric\n"
        "  boolean x = not 42\n"
        "  return 0\n"
        "end_function\n";
    
    bool result = analyze_program_from_source(source);
    ASSERT_FALSE(result, "Unary op with wrong type should fail");
    ASSERT_ERROR_CONTAINS("operator");
    PASS();
}

void test_logical_op_with_int(void) {
    TEST("test_logical_op_with_int");
    
    const char* source =
        "function main() as boolean\n"
        "  boolean x = 10 and 20\n"
        "  return x\n"
        "end_function\n";
    
    bool result = analyze_program_from_source(source);
    ASSERT_FALSE(result, "Logical op with int should fail");
    ASSERT_ERROR_CONTAINS("operator");
    PASS();
}

/* ============================================================================
 * INTEGRATION TESTS (Complex Programs)
 * ============================================================================ */

void test_complex_program(void) {
    TEST("test_complex_program");
    
    const char* source =
        "function factorial(numeric n) as numeric\n"
        "  if n <= 1 then\n"
        "    return 1\n"
        "  end_if\n"
        "  return n * factorial(n - 1)\n"
        "end_function\n"
        "function main() as numeric\n"
        "  numeric result = factorial(5)\n"
        "  return result\n"
        "end_function\n";
    
    bool result = analyze_program_from_source(source);
    ASSERT_TRUE(result, "Complex program should work");
    PASS();
}

void test_multiple_functions(void) {
    TEST("test_multiple_functions");
    
    const char* source =
        "function add(numeric a; numeric b) as numeric\n"
        "  return a + b\n"
        "end_function\n"
        "function subtract(numeric a; numeric b) as numeric\n"
        "  return a - b\n"
        "end_function\n"
        "function main() as numeric\n"
        "  numeric x = add(10; 20)\n"
        "  numeric y = subtract(30; 15)\n"
        "  return x + y\n"
        "end_function\n";
    
    bool result = analyze_program_from_source(source);
    ASSERT_TRUE(result, "Multiple functions should work");
    PASS();
}

void test_nested_control_flow(void) {
    TEST("test_nested_control_flow");
    
    const char* source =
        "function main() as numeric\n"
        "  numeric i = 0\n"
        "  numeric sum = 0\n"
        "  while i < 10\n"
        "    if i mod 2 == 0 then\n"
        "      sum = sum + i\n"
        "    end_if\n"
        "    i = i + 1\n"
        "  end_while\n"
        "  return sum\n"
        "end_function\n";
    
    bool result = analyze_program_from_source(source);
    ASSERT_TRUE(result, "Nested control flow should work");
    PASS();
}

void test_equality_operators(void) {
    TEST("test_equality_operators");
    
    const char* source =
        "function main() as boolean\n"
        "  numeric a = 10\n"
        "  numeric b = 20\n"
        "  boolean c = true\n"
        "  boolean d = false\n"
        "  boolean e = a == b\n"
        "  boolean f = a != b\n"
        "  boolean g = c == d\n"
        "  boolean h = c != d\n"
        "  return e\n"
        "end_function\n";
    
    bool result = analyze_program_from_source(source);
    ASSERT_TRUE(result, "Equality operators should work");
    PASS();
}

/* ============================================================================
 * MAIN TEST RUNNER
 * ============================================================================ */

int main(void) {
    printf("================================================================================\n");
    printf("MELP Stage 2 - Semantic Analyzer Test Suite\n");
    printf("Phase 4.0 - Semantic Analysis Implementation\n");
    printf("================================================================================\n\n");
    
    /* Happy path tests */
    printf("--- HAPPY PATH TESTS ---\n");
    test_simple_function();
    test_variable_declaration();
    test_variable_initialization();
    test_arithmetic_operations();
    test_comparison_operations();
    test_logical_operations();
    test_if_statement();
    test_while_statement();
    test_function_with_parameters();
    test_function_call();
    
    /* Error detection tests */
    printf("\n--- ERROR DETECTION TESTS ---\n");
    test_undefined_variable();
    test_undefined_function();
    test_variable_redeclaration();
    test_function_redeclaration();
    test_type_mismatch_binary_op();
    test_type_mismatch_assignment();
    test_type_mismatch_initialization();
    test_type_mismatch_return();
    test_if_condition_not_boolean();
    test_while_condition_not_boolean();
    test_function_call_wrong_arg_count();
    test_function_call_wrong_arg_type();
    test_unary_op_wrong_type();
    test_logical_op_with_int();
    
    /* Integration tests */
    printf("\n--- INTEGRATION TESTS ---\n");
    test_complex_program();
    test_multiple_functions();
    test_nested_control_flow();
    test_equality_operators();
    
    /* Summary */
    printf("\n================================================================================\n");
    printf("TEST SUMMARY\n");
    printf("================================================================================\n");
    printf("Total Tests:  %d\n", g_test_count);
    printf("Passed:       %d ‚úÖ\n", g_test_passed);
    printf("Failed:       %d ‚ùå\n", g_test_failed);
    printf("Success Rate: %.1f%%\n", (g_test_passed * 100.0) / g_test_count);
    printf("================================================================================\n");
    
    if (g_test_failed == 0) {
        printf("\nüéâ ALL TESTS PASSED! üéâ\n\n");
        return 0;
    } else {
        printf("\n‚ö†Ô∏è  SOME TESTS FAILED ‚ö†Ô∏è\n\n");
        return 1;
    }
}
