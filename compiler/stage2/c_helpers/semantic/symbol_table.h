#ifndef SYMBOL_TABLE_H
#define SYMBOL_TABLE_H

/* MELP Stage 2 - Symbol Table
 * Generated by: YZ_04 (Semantic Analysis Specialist)
 * Date: 15 Ocak 2026
 * Phase: 4.0 - Semantic Analysis Implementation
 * 
 * This header defines the symbol table for tracking variables and functions.
 * 
 * Design Principles:
 * - Scope management (nested scopes with parent pointer)
 * - Symbol tracking (variables, functions, parameters)
 * - Declaration location tracking (for error reporting)
 * - Symbol deduplication (error on redeclaration in same scope)
 */

#include "../common/ast.h"

/* ============================================================================
 * SYMBOL TYPES
 * ============================================================================ */

/* Symbol Classification
 * 
 * SYMBOL_VARIABLE   - Local or global variable
 * SYMBOL_FUNCTION   - Function declaration
 * SYMBOL_PARAMETER  - Function parameter (treated as local variable)
 */
typedef enum {
    SYMBOL_VARIABLE,
    SYMBOL_FUNCTION,
    SYMBOL_PARAMETER
} SymbolKind;

/* Symbol Entry
 * 
 * Represents a declared symbol (variable, function, or parameter).
 * Contains:
 * - name: Symbol identifier
 * - kind: Classification (variable/function/parameter)
 * - type_node: Reference to AST type node (for type checking)
 * - line, column: Declaration location (for error reporting)
 * - Function-specific fields (if kind == SYMBOL_FUNCTION)
 */
typedef struct Symbol {
    char* name;                    /* Symbol name (dynamically allocated) */
    SymbolKind kind;               /* Symbol classification */
    ASTNode* type_node;            /* AST_TYPE node reference */
    int line;                      /* Declaration line (1-based) */
    int column;                    /* Declaration column (1-based) */
    
    /* Function-specific fields (only valid if kind == SYMBOL_FUNCTION) */
    int param_count;               /* Number of parameters */
    struct Symbol** parameters;    /* Array of parameter symbols */
} Symbol;

/* Symbol Table
 * 
 * Represents a scope (global or function-local).
 * Contains:
 * - symbols: Dynamic array of symbol entries
 * - count: Current number of symbols
 * - capacity: Allocated capacity (for dynamic growth)
 * - parent: Pointer to enclosing scope (NULL for global scope)
 * 
 * Scope Hierarchy:
 *   Global Scope (parent = NULL)
 *   └─> Function Scope (parent = global)
 *       └─> (Future: nested block scopes)
 */
typedef struct SymbolTable {
    Symbol** symbols;              /* Dynamic array of symbol pointers */
    int count;                     /* Current symbol count */
    int capacity;                  /* Allocated capacity */
    struct SymbolTable* parent;    /* Enclosing scope (NULL for global) */
} SymbolTable;

/* ============================================================================
 * SYMBOL TABLE API
 * ============================================================================ */

/* Create new symbol table (scope)
 * 
 * Parameters:
 *   parent - Parent scope (NULL for global scope)
 * 
 * Returns:
 *   SymbolTable* - New symbol table (initially empty)
 *   NULL on allocation failure
 * 
 * Example:
 *   SymbolTable* global = create_symbol_table(NULL);
 *   SymbolTable* func_scope = create_symbol_table(global);
 */
SymbolTable* create_symbol_table(SymbolTable* parent);

/* Free symbol table and all symbols
 * 
 * Recursively frees:
 * - All symbol entries (including names)
 * - Symbol array
 * - Symbol table structure
 * 
 * Does NOT free:
 * - Parent scope (caller's responsibility)
 * - AST type_node references (owned by AST)
 * 
 * Safe to call with NULL table.
 */
void free_symbol_table(SymbolTable* table);

/* Add symbol to symbol table
 * 
 * Parameters:
 *   table      - Target symbol table
 *   name       - Symbol name (will be copied)
 *   kind       - Symbol classification
 *   type_node  - AST type node reference (NOT copied)
 *   line       - Declaration line
 *   column     - Declaration column
 * 
 * Returns:
 *   Symbol* - Newly created symbol
 *   NULL if:
 *     - Symbol already exists in THIS scope (redeclaration error)
 *     - Allocation failure
 * 
 * Behavior:
 *   - Checks for redeclaration in CURRENT scope only (not parent)
 *   - Copies name string (caller retains ownership of original)
 *   - Dynamically grows symbol array if needed
 * 
 * Example:
 *   Symbol* var = add_symbol(table, "x", SYMBOL_VARIABLE, type_node, 10, 5);
 *   if (!var) {
 *       // Redeclaration error or allocation failure
 *   }
 */
Symbol* add_symbol(SymbolTable* table, const char* name, SymbolKind kind,
                   ASTNode* type_node, int line, int column);

/* Lookup symbol in symbol table (with scope chain)
 * 
 * Parameters:
 *   table - Symbol table to search
 *   name  - Symbol name
 * 
 * Returns:
 *   Symbol* - Found symbol (from current or parent scope)
 *   NULL if symbol not found in any scope
 * 
 * Behavior:
 *   - Searches current scope first
 *   - Then searches parent scope recursively
 *   - Returns first match (inner scope shadows outer)
 * 
 * Example:
 *   Symbol* sym = lookup_symbol(func_scope, "x");
 *   if (!sym) {
 *       // Undefined variable error
 *   }
 */
Symbol* lookup_symbol(SymbolTable* table, const char* name);

/* Lookup symbol in current scope only (no parent search)
 * 
 * Parameters:
 *   table - Symbol table to search
 *   name  - Symbol name
 * 
 * Returns:
 *   Symbol* - Found symbol in current scope
 *   NULL if symbol not found in current scope
 * 
 * Behavior:
 *   - Searches ONLY current scope (no parent traversal)
 *   - Used for redeclaration detection
 * 
 * Example:
 *   Symbol* sym = lookup_symbol_local(table, "x");
 *   if (sym) {
 *       // Symbol already declared in this scope
 *   }
 */
Symbol* lookup_symbol_local(SymbolTable* table, const char* name);

/* ============================================================================
 * UTILITY FUNCTIONS
 * ============================================================================ */

/* Get human-readable name for symbol kind */
const char* symbol_kind_name(SymbolKind kind);

/* Print symbol table (for debugging) */
void print_symbol_table(SymbolTable* table, int indent);

#endif /* SYMBOL_TABLE_H */
