/* MELP Stage 2 - Semantic Analyzer Implementation
 * Generated by: YZ_04 (Semantic Analysis Specialist)
 * Date: 15 Ocak 2026
 * Phase: 4.0 - Semantic Analysis Implementation
 */

#define _POSIX_C_SOURCE 200809L
#include "semantic_analyzer.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <ctype.h>

/* ============================================================================
 * HELPER FUNCTIONS
 * ============================================================================ */

/* Extract clean identifier from potentially corrupt parser output
 * WORKAROUND: Parser bug - identifiers may not be null-terminated properly
 */
static void extract_clean_name(const char* name, char* buffer, size_t bufsize) {
    size_t len = 0;
    while (name && name[len] && len < (bufsize - 1) && 
           (isalnum(name[len]) || name[len] == '_')) {
        buffer[len] = name[len];
        len++;
    }
    buffer[len] = '\0';
}

/* ============================================================================
 * SEMANTIC CONTEXT
 * ============================================================================ */

/* Internal semantic analysis context */
typedef struct SemanticContext {
    SymbolTable* global_table;    /* Global scope symbol table */
    SymbolTable* current_table;   /* Current scope (global or function) */
    char error_message[512];      /* Error message buffer */
    int error_count;              /* Number of errors detected */
    ASTNode* current_function;    /* Current function being analyzed */
} SemanticContext;

/* Global error state (for get_semantic_error()) */
static char g_error_message[512] = {0};
static int g_error_count = 0;

/* ============================================================================
 * ERROR REPORTING HELPERS
 * ============================================================================ */

static void set_error(SemanticContext* ctx, const char* format, ...) {
    va_list args;
    va_start(args, format);
    vsnprintf(ctx->error_message, sizeof(ctx->error_message), format, args);
    va_end(args);
    
    ctx->error_count++;
    
    /* Copy to global state */
    strncpy(g_error_message, ctx->error_message, sizeof(g_error_message) - 1);
    g_error_count = ctx->error_count;
}

/* ============================================================================
 * FORWARD DECLARATIONS
 * ============================================================================ */

static bool analyze_function(ASTNode* func, SemanticContext* ctx);
static bool analyze_statement(ASTNode* stmt, SemanticContext* ctx);
static Type* analyze_expression(ASTNode* expr, SemanticContext* ctx);
static bool analyze_function_call(ASTNode* call, SemanticContext* ctx);

/* ============================================================================
 * EXPRESSION ANALYSIS
 * ============================================================================ */

static Type* analyze_expression(ASTNode* expr, SemanticContext* ctx) {
    if (!expr) {
        set_error(ctx, "Internal error: NULL expression");
        return create_error_type();
    }
    
    switch (expr->type) {
        case AST_LITERAL: {
            /* Literals are always valid */
            return get_expression_type(expr, ctx->current_table);
        }
        
        case AST_IDENTIFIER: {
            /* Check if variable is defined */
            char clean_name[256];
            extract_clean_name(expr->data.identifier.name, clean_name, sizeof(clean_name));
            
            Symbol* sym = lookup_symbol(ctx->current_table, clean_name);
            if (!sym) {
                set_error(ctx, "Line %d, column %d: undefined variable '%s'",
                         expr->line, expr->column, clean_name);
                return create_error_type();
            }
            
            /* Variable is defined, return its type */
            return ast_type_to_type(sym->type_node);
        }
        
        case AST_BINARY_OP: {
            /* Analyze operands */
            Type* left_type = analyze_expression(expr->data.binary_op.left, ctx);
            Type* right_type = analyze_expression(expr->data.binary_op.right, ctx);
            
            /* Propagate error */
            if (is_error_type(left_type) || is_error_type(right_type)) {
                return create_error_type();
            }
            
            /* Get expected type and result type */
            Type* result_type = NULL;
            Type* expected_type = get_binary_op_expected_type(
                expr->data.binary_op.op, &result_type);
            
            /* Special case: equality operators */
            if (expr->data.binary_op.op == TOKEN_EQUAL_EQUAL ||
                expr->data.binary_op.op == TOKEN_NOT_EQUAL) {
                /* Both operands must be same type (int or bool) */
                if (!types_compatible(left_type, right_type)) {
                    set_error(ctx, "Line %d: equality operator expects same types, got %s and %s",
                             expr->line, type_to_string(left_type), type_to_string(right_type));
                    return create_error_type();
                }
                if (!is_numeric_type(left_type) && !is_boolean_type(left_type)) {
                    set_error(ctx, "Line %d: equality operator expects numeric or boolean, got %s",
                             expr->line, type_to_string(left_type));
                    return create_error_type();
                }
                return create_bool_type();
            }
            
            /* Check operand types */
            if (!types_compatible(left_type, expected_type)) {
                set_error(ctx, "Line %d: binary operator expects %s operands, got %s (left)",
                         expr->line, type_to_string(expected_type), type_to_string(left_type));
                return create_error_type();
            }
            
            if (!types_compatible(right_type, expected_type)) {
                set_error(ctx, "Line %d: binary operator expects %s operands, got %s (right)",
                         expr->line, type_to_string(expected_type), type_to_string(right_type));
                return create_error_type();
            }
            
            return result_type;
        }
        
        case AST_UNARY_OP: {
            /* Analyze operand */
            Type* operand_type = analyze_expression(expr->data.unary_op.operand, ctx);
            
            /* Propagate error */
            if (is_error_type(operand_type)) {
                return create_error_type();
            }
            
            /* Get expected type and result type */
            Type* result_type = NULL;
            Type* expected_type = get_unary_op_expected_type(
                expr->data.unary_op.op, &result_type);
            
            if (!expected_type) {
                set_error(ctx, "Line %d: invalid unary operator", expr->line);
                return create_error_type();
            }
            
            /* Check operand type */
            if (!types_compatible(operand_type, expected_type)) {
                const char* op_name = (expr->data.unary_op.op == TOKEN_NOT) ? "not" : "-";
                set_error(ctx, "Line %d: unary operator '%s' expects %s operand, got %s",
                         expr->line, op_name, type_to_string(expected_type),
                         type_to_string(operand_type));
                return create_error_type();
            }
            
            return result_type;
        }
        
        case AST_FUNCTION_CALL: {
            /* Analyze function call (includes arg checking) */
            if (!analyze_function_call(expr, ctx)) {
                return create_error_type();
            }
            
            /* Lookup function and return its return type */
            Symbol* func = lookup_symbol(ctx->current_table, expr->data.call.name);
            if (!func) {
                /* Error already reported in analyze_function_call */
                return create_error_type();
            }
            
            return ast_type_to_type(func->type_node);
        }
        
        default:
            set_error(ctx, "Line %d: invalid expression node type", expr->line);
            return create_error_type();
    }
}

/* ============================================================================
 * FUNCTION CALL ANALYSIS
 * ============================================================================ */

static bool analyze_function_call(ASTNode* call, SemanticContext* ctx) {
    if (!call || call->type != AST_FUNCTION_CALL) {
        set_error(ctx, "Internal error: invalid function call node");
        return false;
    }
    
    /* Lookup function */
    Symbol* func = lookup_symbol(ctx->current_table, call->data.call.name);
    if (!func) {
        set_error(ctx, "Line %d, column %d: undefined function '%s'",
                 call->line, call->column, call->data.call.name);
        return false;
    }
    
    if (func->kind != SYMBOL_FUNCTION) {
        set_error(ctx, "Line %d, column %d: '%s' is not a function",
                 call->line, call->column, call->data.call.name);
        return false;
    }
    
    /* Check argument count */
    if (call->data.call.argument_count != func->param_count) {
        set_error(ctx, "Line %d: function '%s' expects %d arguments, got %d",
                 call->line, call->data.call.name, func->param_count,
                 call->data.call.argument_count);
        return false;
    }
    
    /* Check argument types */
    for (int i = 0; i < call->data.call.argument_count; i++) {
        Type* arg_type = analyze_expression(call->data.call.arguments[i], ctx);
        
        /* Propagate error */
        if (is_error_type(arg_type)) {
            return false;
        }
        
        /* Get parameter type */
        Type* param_type = ast_type_to_type(func->parameters[i]->type_node);
        
        /* Check compatibility */
        if (!types_compatible(arg_type, param_type)) {
            set_error(ctx, "Line %d: function '%s' argument %d expects %s, got %s",
                     call->line, call->data.call.name, i + 1,
                     type_to_string(param_type), type_to_string(arg_type));
            return false;
        }
    }
    
    return true;
}

/* ============================================================================
 * STATEMENT ANALYSIS
 * ============================================================================ */

static bool analyze_statement(ASTNode* stmt, SemanticContext* ctx) {
    if (!stmt) {
        return true;  /* Empty statement is OK */
    }
    
    switch (stmt->type) {
        case AST_VAR_DECL: {
            /* Check for redeclaration in current scope */
            Symbol* existing = lookup_symbol_local(ctx->current_table, stmt->data.var_decl.name);
            if (existing) {
                set_error(ctx, "Line %d, column %d: redeclaration of '%s' (previously declared at %d:%d)",
                         stmt->line, stmt->column, stmt->data.var_decl.name,
                         existing->line, existing->column);
                return false;
            }
            
            /* Add variable to symbol table */
            Symbol* var = add_symbol(ctx->current_table, stmt->data.var_decl.name,
                                    SYMBOL_VARIABLE, stmt->data.var_decl.type,
                                    stmt->line, stmt->column);
            if (!var) {
                set_error(ctx, "Line %d: failed to add variable '%s'",
                         stmt->line, stmt->data.var_decl.name);
                return false;
            }
            
            /* Check initializer type (if present) */
            if (stmt->data.var_decl.initializer) {
                Type* init_type = analyze_expression(stmt->data.var_decl.initializer, ctx);
                Type* var_type = ast_type_to_type(stmt->data.var_decl.type);
                
                if (is_error_type(init_type)) {
                    return false;
                }
                
                if (!types_compatible(var_type, init_type)) {
                    set_error(ctx, "Line %d: cannot initialize %s variable '%s' with %s",
                             stmt->line, type_to_string(var_type),
                             stmt->data.var_decl.name, type_to_string(init_type));
                    return false;
                }
            }
            
            return true;
        }
        
        case AST_ASSIGNMENT: {
            /* Check if variable is defined */
            Symbol* var = lookup_symbol(ctx->current_table, stmt->data.assignment.name);
            if (!var) {
                set_error(ctx, "Line %d, column %d: undefined variable '%s'",
                         stmt->line, stmt->column, stmt->data.assignment.name);
                return false;
            }
            
            /* Check assignment type compatibility */
            Type* value_type = analyze_expression(stmt->data.assignment.value, ctx);
            Type* var_type = ast_type_to_type(var->type_node);
            
            if (is_error_type(value_type)) {
                return false;
            }
            
            if (!types_compatible(var_type, value_type)) {
                set_error(ctx, "Line %d: cannot assign %s to %s variable '%s'",
                         stmt->line, type_to_string(value_type),
                         type_to_string(var_type), stmt->data.assignment.name);
                return false;
            }
            
            return true;
        }
        
        case AST_IF: {
            /* Check condition type */
            Type* cond_type = analyze_expression(stmt->data.if_stmt.condition, ctx);
            
            if (is_error_type(cond_type)) {
                return false;
            }
            
            if (!is_boolean_type(cond_type)) {
                set_error(ctx, "Line %d: if condition must be boolean, got %s",
                         stmt->line, type_to_string(cond_type));
                return false;
            }
            
            /* Analyze then body */
            for (int i = 0; i < stmt->data.if_stmt.then_count; i++) {
                if (!analyze_statement(stmt->data.if_stmt.then_body[i], ctx)) {
                    return false;
                }
            }
            
            /* Analyze else body (if present) */
            for (int i = 0; i < stmt->data.if_stmt.else_count; i++) {
                if (!analyze_statement(stmt->data.if_stmt.else_body[i], ctx)) {
                    return false;
                }
            }
            
            return true;
        }
        
        case AST_WHILE: {
            /* Check condition type */
            Type* cond_type = analyze_expression(stmt->data.while_stmt.condition, ctx);
            
            if (is_error_type(cond_type)) {
                return false;
            }
            
            if (!is_boolean_type(cond_type)) {
                set_error(ctx, "Line %d: while condition must be boolean, got %s",
                         stmt->line, type_to_string(cond_type));
                return false;
            }
            
            /* Analyze body */
            for (int i = 0; i < stmt->data.while_stmt.body_count; i++) {
                if (!analyze_statement(stmt->data.while_stmt.body[i], ctx)) {
                    return false;
                }
            }
            
            return true;
        }
        
        case AST_RETURN: {
            /* Get function return type */
            if (!ctx->current_function) {
                set_error(ctx, "Line %d: return outside of function", stmt->line);
                return false;
            }
            
            Type* func_return_type = ast_type_to_type(
                ctx->current_function->data.function.return_type);
            
            /* Check return value */
            if (stmt->data.return_stmt.expression) {
                /* Return with value */
                Type* return_type = analyze_expression(stmt->data.return_stmt.expression, ctx);
                
                if (is_error_type(return_type)) {
                    return false;
                }
                
                if (!types_compatible(func_return_type, return_type)) {
                    set_error(ctx, "Line %d: function returns %s, got %s",
                             stmt->line, type_to_string(func_return_type),
                             type_to_string(return_type));
                    return false;
                }
            } else {
                /* Return without value (void) */
                if (!is_void_type(func_return_type)) {
                    set_error(ctx, "Line %d: function returns %s, but return has no value",
                             stmt->line, type_to_string(func_return_type));
                    return false;
                }
            }
            
            return true;
        }
        
        case AST_EXPR_STMT: {
            /* Expression statement (typically function call) */
            /* Note: AST_EXPR_STMT reuses return_stmt union field */
            Type* expr_type = analyze_expression(stmt->data.return_stmt.expression, ctx);
            return !is_error_type(expr_type);
        }
        
        default:
            set_error(ctx, "Line %d: invalid statement type", stmt->line);
            return false;
    }
}

/* ============================================================================
 * FUNCTION ANALYSIS
 * ============================================================================ */

static bool analyze_function(ASTNode* func, SemanticContext* ctx) {
    if (!func || func->type != AST_FUNCTION) {
        set_error(ctx, "Internal error: invalid function node");
        return false;
    }
    
    /* Set current function (for return type checking) */
    ctx->current_function = func;
    
    /* Create function scope */
    SymbolTable* func_scope = create_symbol_table(ctx->global_table);
    if (!func_scope) {
        set_error(ctx, "Line %d: failed to create function scope", func->line);
        return false;
    }
    
    /* Switch to function scope */
    SymbolTable* saved_scope = ctx->current_table;
    ctx->current_table = func_scope;
    
    /* Add parameters to function scope */
    Symbol* func_sym = lookup_symbol(ctx->global_table, func->data.function.name);
    if (func_sym && func_sym->kind == SYMBOL_FUNCTION) {
        /* Copy parameters from function symbol */
        for (int i = 0; i < func->data.function.parameter_count; i++) {
            ASTNode* param = func->data.function.parameters[i];
            
            Symbol* param_sym = add_symbol(func_scope, param->data.parameter.name,
                                          SYMBOL_PARAMETER, param->data.parameter.type,
                                          param->line, param->column);
            if (!param_sym) {
                set_error(ctx, "Line %d: failed to add parameter '%s'",
                         param->line, param->data.parameter.name);
                free_symbol_table(func_scope);
                ctx->current_table = saved_scope;
                return false;
            }
        }
    }
    
    /* Analyze function body */
    for (int i = 0; i < func->data.function.body_count; i++) {
        if (!analyze_statement(func->data.function.body[i], ctx)) {
            free_symbol_table(func_scope);
            ctx->current_table = saved_scope;
            return false;
        }
    }
    
    /* Cleanup */
    free_symbol_table(func_scope);
    ctx->current_table = saved_scope;
    ctx->current_function = NULL;
    
    return true;
}

/* ============================================================================
 * PROGRAM ANALYSIS
 * ============================================================================ */

bool analyze_program(ASTNode* ast) {
    if (!ast || ast->type != AST_PROGRAM) {
        snprintf(g_error_message, sizeof(g_error_message),
                "Internal error: invalid program node");
        g_error_count = 1;
        return false;
    }
    
    /* Reset global error state */
    g_error_message[0] = '\0';
    g_error_count = 0;
    
    /* Create semantic context */
    SemanticContext ctx = {0};
    ctx.global_table = create_symbol_table(NULL);
    if (!ctx.global_table) {
        snprintf(g_error_message, sizeof(g_error_message),
                "Failed to create global symbol table");
        g_error_count = 1;
        return false;
    }
    ctx.current_table = ctx.global_table;
    
    /* First pass: Collect all function declarations */
    for (int i = 0; i < ast->data.program.function_count; i++) {
        ASTNode* func = ast->data.program.functions[i];
        
        /* Check for redeclaration */
        Symbol* existing = lookup_symbol_local(ctx.global_table, func->data.function.name);
        if (existing) {
            set_error(&ctx, "Line %d, column %d: redeclaration of function '%s' (previously declared at %d:%d)",
                     func->line, func->column, func->data.function.name,
                     existing->line, existing->column);
            free_symbol_table(ctx.global_table);
            return false;
        }
        
        /* Add function to global symbol table */
        Symbol* func_sym = add_symbol(ctx.global_table, func->data.function.name,
                                      SYMBOL_FUNCTION, func->data.function.return_type,
                                      func->line, func->column);
        if (!func_sym) {
            set_error(&ctx, "Line %d: failed to add function '%s'",
                     func->line, func->data.function.name);
            free_symbol_table(ctx.global_table);
            return false;
        }
        
        /* Store parameter information */
        func_sym->param_count = func->data.function.parameter_count;
        if (func_sym->param_count > 0) {
            func_sym->parameters = (Symbol**)malloc(func_sym->param_count * sizeof(Symbol*));
            if (!func_sym->parameters) {
                set_error(&ctx, "Line %d: failed to allocate parameter array", func->line);
                free_symbol_table(ctx.global_table);
                return false;
            }
            
            /* Store parameter symbols (for type checking) */
            for (int j = 0; j < func_sym->param_count; j++) {
                ASTNode* param = func->data.function.parameters[j];
                
                /* Create parameter symbol (not added to table yet) */
                Symbol* param_sym = (Symbol*)malloc(sizeof(Symbol));
                if (!param_sym) {
                    set_error(&ctx, "Line %d: failed to allocate parameter symbol", param->line);
                    free_symbol_table(ctx.global_table);
                    return false;
                }
                
                param_sym->name = strdup(param->data.parameter.name);
                param_sym->kind = SYMBOL_PARAMETER;
                param_sym->type_node = param->data.parameter.type;
                param_sym->line = param->line;
                param_sym->column = param->column;
                param_sym->param_count = 0;
                param_sym->parameters = NULL;
                
                func_sym->parameters[j] = param_sym;
            }
        }
    }
    
    /* Second pass: Analyze function bodies */
    for (int i = 0; i < ast->data.program.function_count; i++) {
        if (!analyze_function(ast->data.program.functions[i], &ctx)) {
            free_symbol_table(ctx.global_table);
            return false;
        }
    }
    
    /* Cleanup */
    free_symbol_table(ctx.global_table);
    
    return true;
}

bool analyze_program_from_source(const char* source) {
    /* Parse source (PEER TO PEER!) */
    ASTNode* ast = parse(source);
    if (!ast) {
        /* Parse error - error message already set by parser */
        snprintf(g_error_message, sizeof(g_error_message),
                "Parse error (see parser output)");
        g_error_count = 1;
        return false;
    }
    
    /* Analyze semantics */
    bool result = analyze_program(ast);
    
    /* Cleanup */
    free_ast(ast);
    
    return result;
}

/* ============================================================================
 * ERROR REPORTING API
 * ============================================================================ */

const char* get_semantic_error(void) {
    if (g_error_count == 0) {
        return NULL;
    }
    return g_error_message;
}

int get_semantic_error_count(void) {
    return g_error_count;
}
