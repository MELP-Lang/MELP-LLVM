#ifndef CODEGEN_H
#define CODEGEN_H

/* MELP Stage 2 - LLVM IR Code Generator
 * Generated by: YZ_05 (Code Generation Specialist)
 * Date: 15 Ocak 2026
 * Phase: 5.0 - LLVM IR Code Generation Implementation
 * 
 * This header defines the LLVM IR code generation interface.
 * 
 * Design Principles (AUTONOMOUS):
 * - Peer to semantic: Imports semantic_analyzer.h, calls analyze_program()
 * - Single responsibility: ONLY LLVM IR generation
 * - Text-based output: Generates .ll files (not LLVM C++ API)
 * - Register management: SSA form with virtual registers
 * - Symbol tracking: Uses semantic's symbol table
 */

#include "../semantic/semantic_analyzer.h"
#include <stdbool.h>
#include <stdio.h>

/* ============================================================================
 * CODE GENERATOR CONTEXT
 * ============================================================================ */

/* Code generation context - maintains state during IR generation */
typedef struct CodegenContext {
    FILE* output;                // LLVM IR output file
    SymbolTable* symbols;        // Current scope symbol table
    int register_counter;        // Next available register number (%0, %1, ...)
    int label_counter;           // Next available label number (label1, label2, ...)
    char error_message[512];     // Last error message
    bool has_error;              // Error flag
} CodegenContext;

/* ============================================================================
 * MAIN API
 * ============================================================================ */

/* Generate LLVM IR code from AST
 * 
 * Parameters:
 *   ast - Root AST node (AST_PROGRAM), must be semantically valid
 *   output_file - Path to output .ll file
 * 
 * Returns:
 *   true if code generation succeeded
 *   false if error occurred
 * 
 * Behavior:
 *   1. Opens output file
 *   2. Generates LLVM module header (target triple, etc.)
 *   3. Generates function definitions recursively
 *   4. For each function:
 *      - Function signature
 *      - Parameter allocation (alloca + store)
 *      - Body statements (variables, assignments, control flow)
 *      - Return statement
 * 
 * LLVM IR Features:
 *   - SSA form (single static assignment)
 *   - Virtual registers (%0, %1, %2, ...)
 *   - Basic blocks (entry, then, else, loop, etc.)
 *   - Type system (i64 for int, i1 for bool)
 * 
 * Error Handling:
 *   - File I/O errors
 *   - Invalid AST structure (should not happen after semantic analysis)
 *   - Error message available via get_codegen_error()
 * 
 * Example:
 *   ASTNode* ast = parse(source);
 *   if (ast && analyze_program(ast)) {
 *       if (generate_code(ast, "output.ll")) {
 *           printf("Code generation successful!\n");
 *       }
 *   }
 *   free_ast(ast);
 */
bool generate_code(ASTNode* ast, const char* output_file);

/* Generate LLVM IR code from source (convenience function)
 * 
 * Parameters:
 *   source - Source code string
 *   output_file - Path to output .ll file
 * 
 * Returns:
 *   true if parse + semantic + codegen all succeeded
 *   false if any phase failed
 * 
 * Behavior:
 *   1. Calls parse(source) - PEER TO PARSER!
 *   2. If parse succeeds, calls analyze_program() - PEER TO SEMANTIC!
 *   3. If semantic succeeds, calls generate_code()
 *   4. Cleans up AST
 * 
 * This is the recommended high-level API for full compilation.
 * 
 * Example:
 *   if (generate_code_from_source(source, "output.ll")) {
 *       printf("Compilation successful!\n");
 *       system("llc output.ll -o output.s");
 *       system("gcc output.s -o output");
 *   }
 */
bool generate_code_from_source(const char* source, const char* output_file);

/* Get last code generation error message
 * 
 * Returns:
 *   Error message string (valid until next codegen call)
 *   Empty string if no error
 * 
 * Example:
 *   if (!generate_code(ast, "out.ll")) {
 *       fprintf(stderr, "Codegen error: %s\n", get_codegen_error());
 *   }
 */
const char* get_codegen_error(void);

/* ============================================================================
 * INTERNAL CODE GENERATION FUNCTIONS
 * (Used by codegen.c, exposed for modularity/testing)
 * ============================================================================ */

/* Generate LLVM IR for entire program */
void codegen_program(ASTNode* program, CodegenContext* ctx);

/* Generate LLVM IR for function definition */
void codegen_function(ASTNode* func, CodegenContext* ctx);

/* Generate LLVM IR for statement */
void codegen_statement(ASTNode* stmt, CodegenContext* ctx);

/* Generate LLVM IR for expression
 * Returns: Register name containing result (e.g., "%5")
 * Note: Returned string is static buffer, valid until next call
 */
const char* codegen_expression(ASTNode* expr, CodegenContext* ctx);

/* ============================================================================
 * UTILITY FUNCTIONS
 * ============================================================================ */

/* Convert MELP type to LLVM type string
 * int -> "i64"
 * bool -> "i1"
 * void -> "void"
 */
const char* get_llvm_type(const char* melp_type);

/* Convert binary operator to LLVM instruction
 * "+" -> "add"
 * "-" -> "sub"
 * "*" -> "mul"
 * "/" -> "sdiv"
 * "%" -> "srem"
 * etc.
 */
const char* get_llvm_binary_op(const char* op, const char* type);

/* Convert comparison operator to LLVM icmp predicate
 * "<" -> "slt"
 * ">" -> "sgt"
 * "<=" -> "sle"
 * ">=" -> "sge"
 * "==" -> "eq"
 * "!=" -> "ne"
 */
const char* get_llvm_icmp_pred(const char* op);

/* Generate unique register name (%1, %2, ...)
 * Returns: Static buffer with register name
 */
const char* next_register(CodegenContext* ctx);

/* Generate unique label name (label1, label2, ...)
 * Returns: Static buffer with label name
 */
const char* next_label(CodegenContext* ctx);

#endif // CODEGEN_H
