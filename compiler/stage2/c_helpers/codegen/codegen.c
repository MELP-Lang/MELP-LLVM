/* MELP Stage 2 - LLVM IR Code Generator Implementation
 * Generated by: YZ_05 (Code Generation Specialist)
 * Date: 15 Ocak 2026
 * Phase: 5.0 - LLVM IR Code Generation Implementation
 * 
 * This module generates LLVM IR (text format) from semantically validated AST.
 * 
 * Architecture:
 * - Peer to semantic analyzer (imports semantic_analyzer.h)
 * - Single responsibility: ONLY LLVM IR generation
 * - Text-based output (not LLVM C++ API)
 * - SSA form with virtual registers
 * 
 * LLVM IR Features:
 * - Module header (target triple, data layout)
 * - Function definitions (parameters, body, return)
 * - Variable allocation (alloca on stack)
 * - Expressions (arithmetic, logical, comparison)
 * - Control flow (if-then-else, while loops)
 * - Function calls
 * 
 * Type Mapping:
 * - int → i64
 * - bool → i1
 * - void → void
 */

#include "codegen.h"
#include <stdlib.h>
#include <string.h>

/* Global error state */
static char g_error_message[512] = "";

/* Static buffers for generated names (thread-unsafe but simple) */
static char g_register_buffer[32];
static char g_label_buffer[32];
static char g_expr_result_buffer[32];

/* ============================================================================
 * UTILITY FUNCTIONS
 * ============================================================================ */

/* Clean identifier name (workaround for parser lexeme issue)
 * Extracts first word before space/newline/parenthesis
 */
static const char* clean_identifier(const char* raw_name) {
    static char clean_name[256];
    int i = 0;
    while (raw_name[i] != '\0' && raw_name[i] != ' ' && 
           raw_name[i] != '\n' && raw_name[i] != '(' && 
           raw_name[i] != ')' && raw_name[i] != ';' && i < 255) {
        clean_name[i] = raw_name[i];
        i++;
    }
    clean_name[i] = '\0';
    return clean_name;
}

/* Convert MELP type to LLVM type string */
const char* get_llvm_type(const char* melp_type) {
    if (strcmp(melp_type, "numeric") == 0 || strcmp(melp_type, "int") == 0) {
        return "i64";
    } else if (strcmp(melp_type, "boolean") == 0 || strcmp(melp_type, "bool") == 0) {
        return "i1";
    } else if (strcmp(melp_type, "void") == 0) {
        return "void";
    }
    return "i64"; // Default fallback
}

/* Convert MELP type from AST_TYPE node */
const char* get_llvm_type_from_ast(ASTNode* type_node) {
    if (!type_node || type_node->type != AST_TYPE) {
        return "i64"; // Default
    }
    
    switch (type_node->data.type.type_token) {
        case TOKEN_NUMERIC:
            return "i64";
        case TOKEN_BOOLEAN:
            return "i1";
        default:
            return "i64";
    }
}

/* Convert binary operator to LLVM instruction */
const char* get_llvm_binary_op(const char* op, const char* type) {
    (void)type; // Unused for now, kept for future type-specific operations
    
    // Arithmetic operations (i64)
    if (strcmp(op, "+") == 0) return "add";
    if (strcmp(op, "-") == 0) return "sub";
    if (strcmp(op, "*") == 0) return "mul";
    if (strcmp(op, "/") == 0) return "sdiv";
    if (strcmp(op, "%") == 0) return "srem";
    
    // Logical operations (i1)
    if (strcmp(op, "and") == 0 || strcmp(op, "&&") == 0) return "and";
    if (strcmp(op, "or") == 0 || strcmp(op, "||") == 0) return "or";
    
    return "add"; // Fallback
}

/* Convert TokenType operator to string */
const char* token_type_to_op_string(TokenType op) {
    switch (op) {
        case TOKEN_PLUS: return "+";
        case TOKEN_MINUS: return "-";
        case TOKEN_STAR: return "*";
        case TOKEN_SLASH: return "/";
        case TOKEN_MOD: return "%";
        case TOKEN_AND: return "and";
        case TOKEN_OR: return "or";
        case TOKEN_EQUAL_EQUAL: return "==";
        case TOKEN_NOT_EQUAL: return "!=";
        case TOKEN_LESS: return "<";
        case TOKEN_GREATER: return ">";
        case TOKEN_LESS_EQUAL: return "<=";
        case TOKEN_GREATER_EQUAL: return ">=";
        case TOKEN_NOT: return "!";
        default: return "+";
    }
}

/* Convert comparison operator to LLVM icmp predicate */
const char* get_llvm_icmp_pred(const char* op) {
    if (strcmp(op, "<") == 0) return "slt";
    if (strcmp(op, ">") == 0) return "sgt";
    if (strcmp(op, "<=") == 0) return "sle";
    if (strcmp(op, ">=") == 0) return "sge";
    if (strcmp(op, "==") == 0) return "eq";
    if (strcmp(op, "!=") == 0) return "ne";
    return "eq"; // Fallback
}

/* Generate next register name */
const char* next_register(CodegenContext* ctx) {
    snprintf(g_register_buffer, sizeof(g_register_buffer), "%%%d", ctx->register_counter++);
    return g_register_buffer;
}

/* Generate next label name */
const char* next_label(CodegenContext* ctx) {
    snprintf(g_label_buffer, sizeof(g_label_buffer), "label%d", ctx->label_counter++);
    return g_label_buffer;
}

/* Set codegen error */
static void set_error(CodegenContext* ctx, const char* message) {
    ctx->has_error = true;
    strncpy(ctx->error_message, message, sizeof(ctx->error_message) - 1);
    ctx->error_message[sizeof(ctx->error_message) - 1] = '\0';
    strncpy(g_error_message, message, sizeof(g_error_message) - 1);
    g_error_message[sizeof(g_error_message) - 1] = '\0';
}

/* ============================================================================
 * CODE GENERATION - EXPRESSIONS
 * ============================================================================ */

/* Forward declaration */
const char* codegen_expression(ASTNode* expr, CodegenContext* ctx);

/* Generate code for literal */
static const char* codegen_literal(ASTNode* literal, CodegenContext* ctx) {
    (void)ctx; // Literals don't need context
    static char literal_buffer[32];
    
    switch (literal->data.literal.literal_type) {
        case TOKEN_NUMBER:
            snprintf(literal_buffer, sizeof(literal_buffer), "%lld", 
                     literal->data.literal.value.int_value);
            break;
        case TOKEN_TRUE:
            snprintf(literal_buffer, sizeof(literal_buffer), "true");
            break;
        case TOKEN_FALSE:
            snprintf(literal_buffer, sizeof(literal_buffer), "false");
            break;
        default:
            snprintf(literal_buffer, sizeof(literal_buffer), "0");
    }
    
    return literal_buffer;
}

/* Generate code for identifier (variable reference) */
static const char* codegen_identifier(ASTNode* identifier, CodegenContext* ctx) {
    const char* var_name = clean_identifier(identifier->data.identifier.name);
    
    // Load variable from memory
    const char* result_reg = next_register(ctx);
    fprintf(ctx->output, "  %s = load i64, i64* %%%s\n", result_reg, var_name);
    
    // Return register name (stored in static buffer for reuse)
    strncpy(g_expr_result_buffer, result_reg, sizeof(g_expr_result_buffer) - 1);
    return g_expr_result_buffer;
}

/* Generate code for binary operation */
static const char* codegen_binary_op(ASTNode* binary_op, CodegenContext* ctx) {
    // Generate left and right operands
    const char* left = codegen_expression(binary_op->data.binary_op.left, ctx);
    char left_copy[32];
    strncpy(left_copy, left, sizeof(left_copy) - 1);
    
    const char* right = codegen_expression(binary_op->data.binary_op.right, ctx);
    char right_copy[32];
    strncpy(right_copy, right, sizeof(right_copy) - 1);
    
    const char* op_str = token_type_to_op_string(binary_op->data.binary_op.op);
    const char* result_reg = next_register(ctx);
    
    // Determine operation type
    switch (binary_op->data.binary_op.op) {
        case TOKEN_PLUS:
        case TOKEN_MINUS:
        case TOKEN_STAR:
        case TOKEN_SLASH:
        case TOKEN_MOD: {
            // Arithmetic operations
            const char* llvm_op = get_llvm_binary_op(op_str, "i64");
            fprintf(ctx->output, "  %s = %s i64 %s, %s\n", 
                    result_reg, llvm_op, left_copy, right_copy);
            break;
        }
        
        case TOKEN_LESS:
        case TOKEN_GREATER:
        case TOKEN_LESS_EQUAL:
        case TOKEN_GREATER_EQUAL:
        case TOKEN_EQUAL_EQUAL:
        case TOKEN_NOT_EQUAL: {
            // Comparison operations (result is i1)
            const char* pred = get_llvm_icmp_pred(op_str);
            fprintf(ctx->output, "  %s = icmp %s i64 %s, %s\n", 
                    result_reg, pred, left_copy, right_copy);
            break;
        }
        
        case TOKEN_AND:
        case TOKEN_OR: {
            // Logical operations (operands are i1)
            const char* llvm_op = get_llvm_binary_op(op_str, "i1");
            fprintf(ctx->output, "  %s = %s i1 %s, %s\n", 
                    result_reg, llvm_op, left_copy, right_copy);
            break;
        }
        
        default:
            fprintf(ctx->output, "  %s = add i64 %s, %s\n", 
                    result_reg, left_copy, right_copy);
    }
    
    strncpy(g_expr_result_buffer, result_reg, sizeof(g_expr_result_buffer) - 1);
    return g_expr_result_buffer;
}

/* Generate code for unary operation */
static const char* codegen_unary_op(ASTNode* unary_op, CodegenContext* ctx) {
    const char* operand = codegen_expression(unary_op->data.unary_op.operand, ctx);
    char operand_copy[32];
    strncpy(operand_copy, operand, sizeof(operand_copy) - 1);
    
    const char* result_reg = next_register(ctx);
    
    switch (unary_op->data.unary_op.op) {
        case TOKEN_MINUS:
            // Negate: 0 - operand
            fprintf(ctx->output, "  %s = sub i64 0, %s\n", result_reg, operand_copy);
            break;
            
        case TOKEN_NOT:
            // Logical not: xor operand, true
            fprintf(ctx->output, "  %s = xor i1 %s, true\n", result_reg, operand_copy);
            break;
            
        default:
            fprintf(ctx->output, "  %s = sub i64 0, %s\n", result_reg, operand_copy);
    }
    
    strncpy(g_expr_result_buffer, result_reg, sizeof(g_expr_result_buffer) - 1);
    return g_expr_result_buffer;
}

/* Generate code for function call */
static const char* codegen_function_call(ASTNode* call, CodegenContext* ctx) {
    const char* func_name = clean_identifier(call->data.call.name);
    
    // Evaluate arguments
    char* arg_regs[64];
    for (int i = 0; i < call->data.call.argument_count; i++) {
        const char* arg_reg = codegen_expression(call->data.call.arguments[i], ctx);
        arg_regs[i] = malloc(32);
        strncpy(arg_regs[i], arg_reg, 31);
        arg_regs[i][31] = '\0';
    }
    
    // Generate call instruction
    const char* result_reg = next_register(ctx);
    fprintf(ctx->output, "  %s = call i64 @%s(", result_reg, func_name);
    
    for (int i = 0; i < call->data.call.argument_count; i++) {
        if (i > 0) fprintf(ctx->output, ", ");
        fprintf(ctx->output, "i64 %s", arg_regs[i]);
    }
    
    fprintf(ctx->output, ")\n");
    
    // Free argument register buffers
    for (int i = 0; i < call->data.call.argument_count; i++) {
        free(arg_regs[i]);
    }
    
    strncpy(g_expr_result_buffer, result_reg, sizeof(g_expr_result_buffer) - 1);
    return g_expr_result_buffer;
}

/* Generate code for expression (main entry point) */
const char* codegen_expression(ASTNode* expr, CodegenContext* ctx) {
    if (!expr) {
        return "0";
    }
    
    switch (expr->type) {
        case AST_LITERAL:
            return codegen_literal(expr, ctx);
            
        case AST_IDENTIFIER:
            return codegen_identifier(expr, ctx);
            
        case AST_BINARY_OP:
            return codegen_binary_op(expr, ctx);
            
        case AST_UNARY_OP:
            return codegen_unary_op(expr, ctx);
            
        case AST_FUNCTION_CALL:
            return codegen_function_call(expr, ctx);
            
        default:
            return "0";
    }
}

/* ============================================================================
 * CODE GENERATION - STATEMENTS
 * ============================================================================ */

/* Forward declaration */
void codegen_statement(ASTNode* stmt, CodegenContext* ctx);

/* Generate code for return statement */
static void codegen_return(ASTNode* return_stmt, CodegenContext* ctx) {
    if (return_stmt->data.return_stmt.expression) {
        const char* result = codegen_expression(return_stmt->data.return_stmt.expression, ctx);
        fprintf(ctx->output, "  ret i64 %s\n", result);
    } else {
        fprintf(ctx->output, "  ret void\n");
    }
}

/* Generate code for variable declaration */
static void codegen_var_decl(ASTNode* var_decl, CodegenContext* ctx) {
    const char* var_name = clean_identifier(var_decl->data.var_decl.name);
    const char* llvm_type = get_llvm_type_from_ast(var_decl->data.var_decl.type);
    
    // Allocate variable on stack
    fprintf(ctx->output, "  %%%s = alloca %s\n", var_name, llvm_type);
    
    // Initialize if initializer provided
    if (var_decl->data.var_decl.initializer) {
        const char* init_value = codegen_expression(var_decl->data.var_decl.initializer, ctx);
        fprintf(ctx->output, "  store %s %s, %s* %%%s\n", 
                llvm_type, init_value, llvm_type, var_name);
    }
}

/* Generate code for assignment */
static void codegen_assignment(ASTNode* assignment, CodegenContext* ctx) {
    const char* var_name = clean_identifier(assignment->data.assignment.name);
    const char* value = codegen_expression(assignment->data.assignment.value, ctx);
    
    // Store value to variable
    fprintf(ctx->output, "  store i64 %s, i64* %%%s\n", value, var_name);
}

/* Generate code for if statement */
static void codegen_if(ASTNode* if_stmt, CodegenContext* ctx) {
    // Generate unique labels
    char then_label[32], else_label[32], endif_label[32];
    snprintf(then_label, sizeof(then_label), "then%d", ctx->label_counter);
    snprintf(else_label, sizeof(else_label), "else%d", ctx->label_counter);
    snprintf(endif_label, sizeof(endif_label), "endif%d", ctx->label_counter);
    ctx->label_counter++;
    
    // Evaluate condition
    const char* cond_reg = codegen_expression(if_stmt->data.if_stmt.condition, ctx);
    
    // Branch based on condition
    if (if_stmt->data.if_stmt.else_count > 0) {
        fprintf(ctx->output, "  br i1 %s, label %%%s, label %%%s\n", 
                cond_reg, then_label, else_label);
    } else {
        fprintf(ctx->output, "  br i1 %s, label %%%s, label %%%s\n", 
                cond_reg, then_label, endif_label);
    }
    
    // Then block
    fprintf(ctx->output, "\n%s:\n", then_label);
    for (int i = 0; i < if_stmt->data.if_stmt.then_count; i++) {
        codegen_statement(if_stmt->data.if_stmt.then_body[i], ctx);
    }
    fprintf(ctx->output, "  br label %%%s\n", endif_label);
    
    // Else block (if exists)
    if (if_stmt->data.if_stmt.else_count > 0) {
        fprintf(ctx->output, "\n%s:\n", else_label);
        for (int i = 0; i < if_stmt->data.if_stmt.else_count; i++) {
            codegen_statement(if_stmt->data.if_stmt.else_body[i], ctx);
        }
        fprintf(ctx->output, "  br label %%%s\n", endif_label);
    }
    
    // End if block
    fprintf(ctx->output, "\n%s:\n", endif_label);
}

/* Generate code for while statement */
static void codegen_while(ASTNode* while_stmt, CodegenContext* ctx) {
    // Generate unique labels
    char loop_label[32], body_label[32], endloop_label[32];
    snprintf(loop_label, sizeof(loop_label), "loop%d", ctx->label_counter);
    snprintf(body_label, sizeof(body_label), "body%d", ctx->label_counter);
    snprintf(endloop_label, sizeof(endloop_label), "endloop%d", ctx->label_counter);
    ctx->label_counter++;
    
    // Jump to loop header
    fprintf(ctx->output, "  br label %%%s\n", loop_label);
    
    // Loop header - check condition
    fprintf(ctx->output, "\n%s:\n", loop_label);
    const char* cond_reg = codegen_expression(while_stmt->data.while_stmt.condition, ctx);
    fprintf(ctx->output, "  br i1 %s, label %%%s, label %%%s\n", 
            cond_reg, body_label, endloop_label);
    
    // Loop body
    fprintf(ctx->output, "\n%s:\n", body_label);
    for (int i = 0; i < while_stmt->data.while_stmt.body_count; i++) {
        codegen_statement(while_stmt->data.while_stmt.body[i], ctx);
    }
    fprintf(ctx->output, "  br label %%%s\n", loop_label);
    
    // End loop
    fprintf(ctx->output, "\n%s:\n", endloop_label);
}

/* Generate code for expression statement */
static void codegen_expr_stmt(ASTNode* expr_stmt, CodegenContext* ctx) {
    // Just evaluate expression (e.g., function call)
    codegen_expression(expr_stmt->data.return_stmt.expression, ctx);
}

/* Generate code for statement (main entry point) */
void codegen_statement(ASTNode* stmt, CodegenContext* ctx) {
    if (!stmt) return;
    
    switch (stmt->type) {
        case AST_RETURN:
            codegen_return(stmt, ctx);
            break;
            
        case AST_VAR_DECL:
            codegen_var_decl(stmt, ctx);
            break;
            
        case AST_ASSIGNMENT:
            codegen_assignment(stmt, ctx);
            break;
            
        case AST_IF:
            codegen_if(stmt, ctx);
            break;
            
        case AST_WHILE:
            codegen_while(stmt, ctx);
            break;
            
        case AST_EXPR_STMT:
            codegen_expr_stmt(stmt, ctx);
            break;
            
        default:
            break;
    }
}

/* ============================================================================
 * CODE GENERATION - FUNCTIONS
 * ============================================================================ */

/* Generate code for function definition */
void codegen_function(ASTNode* func, CodegenContext* ctx) {
    const char* func_name = clean_identifier(func->data.function.name);
    const char* return_type = get_llvm_type_from_ast(func->data.function.return_type);
    
    // Reset register counter for each function (SSA numbering starts fresh)
    ctx->register_counter = func->data.function.parameter_count;
    
    // Function signature
    fprintf(ctx->output, "define %s @%s(", return_type, func_name);
    
    // Parameters in signature
    for (int i = 0; i < func->data.function.parameter_count; i++) {
        if (i > 0) fprintf(ctx->output, ", ");
        ASTNode* param = func->data.function.parameters[i];
        const char* param_type = get_llvm_type_from_ast(param->data.parameter.type);
        fprintf(ctx->output, "%s %%%d", param_type, i);
    }
    
    fprintf(ctx->output, ") {\n");
    fprintf(ctx->output, "entry:\n");
    
    // Allocate and store parameters
    for (int i = 0; i < func->data.function.parameter_count; i++) {
        ASTNode* param = func->data.function.parameters[i];
        const char* param_name = clean_identifier(param->data.parameter.name);
        const char* param_type = get_llvm_type_from_ast(param->data.parameter.type);
        
        fprintf(ctx->output, "  %%%s = alloca %s\n", param_name, param_type);
        fprintf(ctx->output, "  store %s %%%d, %s* %%%s\n", 
                param_type, i, param_type, param_name);
    }
    
    // Generate function body
    for (int i = 0; i < func->data.function.body_count; i++) {
        codegen_statement(func->data.function.body[i], ctx);
    }
    
    // Ensure function ends with return (if not already present)
    // This is a safety measure - semantic analysis should ensure returns exist
    if (func->data.function.body_count == 0 || 
        func->data.function.body[func->data.function.body_count - 1]->type != AST_RETURN) {
        if (strcmp(return_type, "void") == 0) {
            fprintf(ctx->output, "  ret void\n");
        } else {
            fprintf(ctx->output, "  ret %s 0\n", return_type);
        }
    }
    
    fprintf(ctx->output, "}\n\n");
}

/* ============================================================================
 * CODE GENERATION - PROGRAM
 * ============================================================================ */

/* Generate module header */
static void generate_module_header(CodegenContext* ctx) {
    fprintf(ctx->output, 
        "; MELP Stage 2 - Generated LLVM IR\n"
        "; Generated by: YZ_05 (Code Generation Specialist)\n\n");
    
    fprintf(ctx->output, 
        "target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-"
        "i64:64-f80:128-n8:16:32:64-S128\"\n");
    fprintf(ctx->output, "target triple = \"x86_64-pc-linux-gnu\"\n\n");
    
    // External declarations (for standard library functions if needed)
    fprintf(ctx->output, "; External declarations\n");
    fprintf(ctx->output, "declare i32 @printf(i8*, ...)\n");
    fprintf(ctx->output, "declare i32 @scanf(i8*, ...)\n\n");
}

/* Generate forward declarations for all functions
 * This allows functions to call each other regardless of definition order
 */
static void generate_forward_declarations(ASTNode* program, CodegenContext* ctx) {
    fprintf(ctx->output, "; Forward declarations\n");
    
    for (int i = 0; i < program->data.program.function_count; i++) {
        ASTNode* func = program->data.program.functions[i];
        const char* func_name = clean_identifier(func->data.function.name);
        const char* return_type = get_llvm_type_from_ast(func->data.function.return_type);
        
        // Function declaration (no body)
        fprintf(ctx->output, "declare %s @%s(", return_type, func_name);
        
        // Parameters in signature
        for (int j = 0; j < func->data.function.parameter_count; j++) {
            if (j > 0) fprintf(ctx->output, ", ");
            ASTNode* param = func->data.function.parameters[j];
            const char* param_type = get_llvm_type_from_ast(param->data.parameter.type);
            fprintf(ctx->output, "%s", param_type);
        }
        
        fprintf(ctx->output, ")\n");
    }
    
    fprintf(ctx->output, "\n");
}

/* Generate code for entire program */
void codegen_program(ASTNode* program, CodegenContext* ctx) {
    if (!program || program->type != AST_PROGRAM) {
        set_error(ctx, "Invalid AST: expected AST_PROGRAM node");
        return;
    }
    
    // Generate module header
    generate_module_header(ctx);
    
    // Note: Forward declarations removed - LLVM IR doesn't require them
    // Functions can be called before they are defined in LLVM IR
    
    // Generate all functions
    for (int i = 0; i < program->data.program.function_count; i++) {
        codegen_function(program->data.program.functions[i], ctx);
    }
}

/* ============================================================================
 * MAIN API IMPLEMENTATION
 * ============================================================================ */

/* Generate LLVM IR code from AST */
bool generate_code(ASTNode* ast, const char* output_file) {
    if (!ast) {
        strncpy(g_error_message, "NULL AST provided", sizeof(g_error_message) - 1);
        return false;
    }
    
    if (!output_file) {
        strncpy(g_error_message, "NULL output file provided", sizeof(g_error_message) - 1);
        return false;
    }
    
    // Open output file
    FILE* output = fopen(output_file, "w");
    if (!output) {
        snprintf(g_error_message, sizeof(g_error_message), 
                 "Failed to open output file: %s", output_file);
        return false;
    }
    
    // Initialize context
    CodegenContext ctx = {
        .output = output,
        .symbols = NULL,
        .register_counter = 0,
        .label_counter = 1,
        .has_error = false
    };
    ctx.error_message[0] = '\0';
    
    // Generate code
    codegen_program(ast, &ctx);
    
    // Close output file
    fclose(output);
    
    return !ctx.has_error;
}

/* Generate LLVM IR code from source (convenience function) */
bool generate_code_from_source(const char* source, const char* output_file) {
    if (!source) {
        strncpy(g_error_message, "NULL source provided", sizeof(g_error_message) - 1);
        return false;
    }
    
    // Parse source (peer to parser)
    ASTNode* ast = parse(source);
    if (!ast) {
        strncpy(g_error_message, "Parse error: ", sizeof(g_error_message) - 1);
        strncat(g_error_message, get_parse_error(), 
                sizeof(g_error_message) - strlen(g_error_message) - 1);
        return false;
    }
    
    // Analyze program (peer to semantic)
    if (!analyze_program(ast)) {
        strncpy(g_error_message, "Semantic error: ", sizeof(g_error_message) - 1);
        strncat(g_error_message, get_semantic_error(), 
                sizeof(g_error_message) - strlen(g_error_message) - 1);
        free_ast(ast);
        return false;
    }
    
    // Generate code
    bool success = generate_code(ast, output_file);
    
    // Clean up
    free_ast(ast);
    
    return success;
}

/* Get last code generation error message */
const char* get_codegen_error(void) {
    return g_error_message;
}
