/* MELP Stage 2 - Lexer Unit Tests
 * Generated by: YZ_02 (Lexer Specialist)
 * Date: 15 Ocak 2026
 * Phase: 2.0 - Lexer Implementation (Task 2.4)
 * 
 * Comprehensive test suite for lexer_impl.c
 * >10 test cases covering all token types and edge cases
 */

#include "../lexer/lexer_impl.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

/* Test counter */
static int tests_passed = 0;
static int tests_failed = 0;

/* Helper: Print token for debugging */
void print_token(Token* token) {
    printf("  [%s] '%.*s' at line %d:%d", 
           token_type_name(token->type),
           token->lexeme_length,
           token->lexeme,
           token->line,
           token->column);
    
    if (token->type == TOKEN_NUMBER) {
        printf(" (value=%lld)", token->value.int_value);
    }
    
    printf("\n");
}

/* Helper: Assert token properties */
void assert_token(Token* token, TokenType expected_type, const char* expected_lexeme, 
                  int expected_line, int expected_column) {
    if (token->type != expected_type) {
        printf("  âŒ Expected type %s, got %s\n", 
               token_type_name(expected_type),
               token_type_name(token->type));
        tests_failed++;
        return;
    }
    
    if (expected_lexeme != NULL) {
        int len = strlen(expected_lexeme);
        if (token->lexeme_length != len || 
            memcmp(token->lexeme, expected_lexeme, len) != 0) {
            printf("  âŒ Expected lexeme '%s', got '%.*s'\n",
                   expected_lexeme, token->lexeme_length, token->lexeme);
            tests_failed++;
            return;
        }
    }
    
    if (token->line != expected_line) {
        printf("  âŒ Expected line %d, got %d\n", expected_line, token->line);
        tests_failed++;
        return;
    }
    
    if (token->column != expected_column) {
        printf("  âŒ Expected column %d, got %d\n", expected_column, token->column);
        tests_failed++;
        return;
    }
}

/* ============================================================================
 * TEST CASES
 * ============================================================================ */

/* Test 1: Number Literals */
void test_numbers() {
    printf("Test 1: Number Literals\n");
    
    const char* source = "42 100 999 0";
    int count;
    Token* tokens = tokenize(source, &count);
    
    assert(tokens != NULL);
    assert(count == 5);  /* 4 numbers + EOF */
    
    assert_token(&tokens[0], TOKEN_NUMBER, "42", 1, 1);
    assert(tokens[0].value.int_value == 42);
    
    assert_token(&tokens[1], TOKEN_NUMBER, "100", 1, 4);
    assert(tokens[1].value.int_value == 100);
    
    assert_token(&tokens[2], TOKEN_NUMBER, "999", 1, 8);
    assert(tokens[2].value.int_value == 999);
    
    assert_token(&tokens[3], TOKEN_NUMBER, "0", 1, 12);
    assert(tokens[3].value.int_value == 0);
    
    assert_token(&tokens[4], TOKEN_EOF, "", 1, 13);
    
    free_tokens(tokens, count);
    tests_passed++;
    printf("âœ… Test 1 PASSED\n\n");
}

/* Test 2: Boolean Literals */
void test_booleans() {
    printf("Test 2: Boolean Literals\n");
    
    const char* source = "true false";
    int count;
    Token* tokens = tokenize(source, &count);
    
    assert(tokens != NULL);
    assert(count == 3);  /* true, false, EOF */
    
    assert_token(&tokens[0], TOKEN_TRUE, "true", 1, 1);
    assert_token(&tokens[1], TOKEN_FALSE, "false", 1, 6);
    assert_token(&tokens[2], TOKEN_EOF, "", 1, 11);
    
    free_tokens(tokens, count);
    tests_passed++;
    printf("âœ… Test 2 PASSED\n\n");
}

/* Test 3: Identifiers */
void test_identifiers() {
    printf("Test 3: Identifiers\n");
    
    const char* source = "x my_var result123 _test";
    int count;
    Token* tokens = tokenize(source, &count);
    
    assert(tokens != NULL);
    assert(count == 5);  /* 4 identifiers + EOF */
    
    assert_token(&tokens[0], TOKEN_IDENTIFIER, "x", 1, 1);
    assert_token(&tokens[1], TOKEN_IDENTIFIER, "my_var", 1, 3);
    assert_token(&tokens[2], TOKEN_IDENTIFIER, "result123", 1, 10);
    assert_token(&tokens[3], TOKEN_IDENTIFIER, "_test", 1, 20);
    assert_token(&tokens[4], TOKEN_EOF, "", 1, 25);
    
    free_tokens(tokens, count);
    tests_passed++;
    printf("âœ… Test 3 PASSED\n\n");
}

/* Test 4: Function Keywords */
void test_function_keywords() {
    printf("Test 4: Function Keywords\n");
    
    const char* source = "function end_function return as";
    int count;
    Token* tokens = tokenize(source, &count);
    
    assert(tokens != NULL);
    assert(count == 5);
    
    assert_token(&tokens[0], TOKEN_FUNCTION, "function", 1, 1);
    assert_token(&tokens[1], TOKEN_END_FUNCTION, "end_function", 1, 10);
    assert_token(&tokens[2], TOKEN_RETURN, "return", 1, 23);
    assert_token(&tokens[3], TOKEN_AS, "as", 1, 30);
    assert_token(&tokens[4], TOKEN_EOF, "", 1, 32);
    
    free_tokens(tokens, count);
    tests_passed++;
    printf("âœ… Test 4 PASSED\n\n");
}

/* Test 5: Control Flow Keywords */
void test_control_flow_keywords() {
    printf("Test 5: Control Flow Keywords\n");
    
    const char* source = "if then else else_if end_if while end_while";
    int count;
    Token* tokens = tokenize(source, &count);
    
    assert(tokens != NULL);
    assert(count == 8);
    
    assert_token(&tokens[0], TOKEN_IF, "if", 1, 1);
    assert_token(&tokens[1], TOKEN_THEN, "then", 1, 4);
    assert_token(&tokens[2], TOKEN_ELSE, "else", 1, 9);
    assert_token(&tokens[3], TOKEN_ELSE_IF, "else_if", 1, 14);
    assert_token(&tokens[4], TOKEN_END_IF, "end_if", 1, 22);
    assert_token(&tokens[5], TOKEN_WHILE, "while", 1, 29);
    assert_token(&tokens[6], TOKEN_END_WHILE, "end_while", 1, 35);
    assert_token(&tokens[7], TOKEN_EOF, "", 1, 44);
    
    free_tokens(tokens, count);
    tests_passed++;
    printf("âœ… Test 5 PASSED\n\n");
}

/* Test 6: Type Keywords */
void test_type_keywords() {
    printf("Test 6: Type Keywords\n");
    
    const char* source = "numeric boolean var";
    int count;
    Token* tokens = tokenize(source, &count);
    
    assert(tokens != NULL);
    assert(count == 4);
    
    assert_token(&tokens[0], TOKEN_NUMERIC, "numeric", 1, 1);
    assert_token(&tokens[1], TOKEN_BOOLEAN, "boolean", 1, 9);
    assert_token(&tokens[2], TOKEN_VAR, "var", 1, 17);
    assert_token(&tokens[3], TOKEN_EOF, "", 1, 20);
    
    free_tokens(tokens, count);
    tests_passed++;
    printf("âœ… Test 6 PASSED\n\n");
}

/* Test 7: Arithmetic Operators */
void test_arithmetic_operators() {
    printf("Test 7: Arithmetic Operators\n");
    
    const char* source = "+ - * / mod";
    int count;
    Token* tokens = tokenize(source, &count);
    
    assert(tokens != NULL);
    assert(count == 6);
    
    assert_token(&tokens[0], TOKEN_PLUS, "+", 1, 1);
    assert_token(&tokens[1], TOKEN_MINUS, "-", 1, 3);
    assert_token(&tokens[2], TOKEN_STAR, "*", 1, 5);
    assert_token(&tokens[3], TOKEN_SLASH, "/", 1, 7);
    assert_token(&tokens[4], TOKEN_MOD, "mod", 1, 9);
    assert_token(&tokens[5], TOKEN_EOF, "", 1, 12);
    
    free_tokens(tokens, count);
    tests_passed++;
    printf("âœ… Test 7 PASSED\n\n");
}

/* Test 8: Comparison Operators */
void test_comparison_operators() {
    printf("Test 8: Comparison Operators\n");
    
    const char* source = "== != < <= > >=";
    int count;
    Token* tokens = tokenize(source, &count);
    
    assert(tokens != NULL);
    assert(count == 7);
    
    assert_token(&tokens[0], TOKEN_EQUAL_EQUAL, "==", 1, 1);
    assert_token(&tokens[1], TOKEN_NOT_EQUAL, "!=", 1, 4);
    assert_token(&tokens[2], TOKEN_LESS, "<", 1, 7);
    assert_token(&tokens[3], TOKEN_LESS_EQUAL, "<=", 1, 9);
    assert_token(&tokens[4], TOKEN_GREATER, ">", 1, 12);
    assert_token(&tokens[5], TOKEN_GREATER_EQUAL, ">=", 1, 14);
    assert_token(&tokens[6], TOKEN_EOF, "", 1, 16);
    
    free_tokens(tokens, count);
    tests_passed++;
    printf("âœ… Test 8 PASSED\n\n");
}

/* Test 9: Logical Operators */
void test_logical_operators() {
    printf("Test 9: Logical Operators\n");
    
    const char* source = "and or not";
    int count;
    Token* tokens = tokenize(source, &count);
    
    assert(tokens != NULL);
    assert(count == 4);
    
    assert_token(&tokens[0], TOKEN_AND, "and", 1, 1);
    assert_token(&tokens[1], TOKEN_OR, "or", 1, 5);
    assert_token(&tokens[2], TOKEN_NOT, "not", 1, 8);
    assert_token(&tokens[3], TOKEN_EOF, "", 1, 11);
    
    free_tokens(tokens, count);
    tests_passed++;
    printf("âœ… Test 9 PASSED\n\n");
}

/* Test 10: Delimiters */
void test_delimiters() {
    printf("Test 10: Delimiters\n");
    
    const char* source = "( ) [ ] ; ,";
    int count;
    Token* tokens = tokenize(source, &count);
    
    assert(tokens != NULL);
    assert(count == 7);
    
    assert_token(&tokens[0], TOKEN_LEFT_PAREN, "(", 1, 1);
    assert_token(&tokens[1], TOKEN_RIGHT_PAREN, ")", 1, 3);
    assert_token(&tokens[2], TOKEN_LEFT_BRACKET, "[", 1, 5);
    assert_token(&tokens[3], TOKEN_RIGHT_BRACKET, "]", 1, 7);
    assert_token(&tokens[4], TOKEN_SEMICOLON, ";", 1, 9);
    assert_token(&tokens[5], TOKEN_COMMA, ",", 1, 11);
    assert_token(&tokens[6], TOKEN_EOF, "", 1, 12);
    
    free_tokens(tokens, count);
    tests_passed++;
    printf("âœ… Test 10 PASSED\n\n");
}

/* Test 11: Complex Expression */
void test_complex_expression() {
    printf("Test 11: Complex Expression\n");
    
    const char* source = "x = y + 10";
    int count;
    Token* tokens = tokenize(source, &count);
    
    assert(tokens != NULL);
    assert(count == 6);  /* x, =, y, +, 10, EOF */
    
    assert_token(&tokens[0], TOKEN_IDENTIFIER, "x", 1, 1);
    assert_token(&tokens[1], TOKEN_EQUAL, "=", 1, 3);
    assert_token(&tokens[2], TOKEN_IDENTIFIER, "y", 1, 5);
    assert_token(&tokens[3], TOKEN_PLUS, "+", 1, 7);
    assert_token(&tokens[4], TOKEN_NUMBER, "10", 1, 9);
    assert(tokens[4].value.int_value == 10);
    assert_token(&tokens[5], TOKEN_EOF, "", 1, 11);
    
    free_tokens(tokens, count);
    tests_passed++;
    printf("âœ… Test 11 PASSED\n\n");
}

/* Test 12: Function Declaration */
void test_function_declaration() {
    printf("Test 12: Function Declaration\n");
    
    const char* source = "function main() as numeric";
    int count;
    Token* tokens = tokenize(source, &count);
    
    assert(tokens != NULL);
    assert(count == 7);  /* function, main, (, ), as, numeric, EOF */
    
    assert_token(&tokens[0], TOKEN_FUNCTION, "function", 1, 1);
    assert_token(&tokens[1], TOKEN_IDENTIFIER, "main", 1, 10);
    assert_token(&tokens[2], TOKEN_LEFT_PAREN, "(", 1, 14);
    assert_token(&tokens[3], TOKEN_RIGHT_PAREN, ")", 1, 15);
    assert_token(&tokens[4], TOKEN_AS, "as", 1, 17);
    assert_token(&tokens[5], TOKEN_NUMERIC, "numeric", 1, 20);
    assert_token(&tokens[6], TOKEN_EOF, "", 1, 27);
    
    free_tokens(tokens, count);
    tests_passed++;
    printf("âœ… Test 12 PASSED\n\n");
}

/* Test 13: Multi-line Code */
void test_multiline() {
    printf("Test 13: Multi-line Code\n");
    
    const char* source = "x\ny\nz";
    int count;
    Token* tokens = tokenize(source, &count);
    
    assert(tokens != NULL);
    /* x, NEWLINE, y, NEWLINE, z, EOF */
    assert(count == 6);
    
    assert_token(&tokens[0], TOKEN_IDENTIFIER, "x", 1, 1);
    assert_token(&tokens[1], TOKEN_NEWLINE, "\n", 1, 2);
    assert_token(&tokens[2], TOKEN_IDENTIFIER, "y", 2, 1);
    assert_token(&tokens[3], TOKEN_NEWLINE, "\n", 2, 2);
    assert_token(&tokens[4], TOKEN_IDENTIFIER, "z", 3, 1);
    assert_token(&tokens[5], TOKEN_EOF, "", 3, 2);
    
    free_tokens(tokens, count);
    tests_passed++;
    printf("âœ… Test 13 PASSED\n\n");
}

/* Test 14: Comments */
void test_comments() {
    printf("Test 14: Comments\n");
    
    const char* source = "x -- this is a comment\ny";
    int count;
    Token* tokens = tokenize(source, &count);
    
    assert(tokens != NULL);
    /* Comments are skipped, so: x, NEWLINE, y, EOF */
    assert(count == 4);
    
    assert_token(&tokens[0], TOKEN_IDENTIFIER, "x", 1, 1);
    assert_token(&tokens[1], TOKEN_NEWLINE, "\n", 1, 23);
    assert_token(&tokens[2], TOKEN_IDENTIFIER, "y", 2, 1);
    assert_token(&tokens[3], TOKEN_EOF, "", 2, 2);
    
    free_tokens(tokens, count);
    tests_passed++;
    printf("âœ… Test 14 PASSED\n\n");
}

/* Test 15: String Literals */
void test_strings() {
    printf("Test 15: String Literals\n");
    
    const char* source = "\"hello\" \"world\"";
    int count;
    Token* tokens = tokenize(source, &count);
    
    assert(tokens != NULL);
    assert(count == 3);  /* 2 strings + EOF */
    
    assert_token(&tokens[0], TOKEN_STRING, "\"hello\"", 1, 1);
    assert(strcmp(tokens[0].value.str_value, "hello") == 0);
    
    assert_token(&tokens[1], TOKEN_STRING, "\"world\"", 1, 9);
    assert(strcmp(tokens[1].value.str_value, "world") == 0);
    
    assert_token(&tokens[2], TOKEN_EOF, "", 1, 16);
    
    free_tokens(tokens, count);
    tests_passed++;
    printf("âœ… Test 15 PASSED\n\n");
}

/* Test 16: Error - Invalid Character */
void test_error_invalid_character() {
    printf("Test 16: Error - Invalid Character\n");
    
    const char* source = "x @ y";
    int count;
    Token* tokens = tokenize(source, &count);
    
    assert(tokens != NULL);
    /* x, ERROR(@), y, EOF */
    assert(count == 4);
    
    assert_token(&tokens[0], TOKEN_IDENTIFIER, "x", 1, 1);
    assert_token(&tokens[1], TOKEN_ERROR, NULL, 1, 3);  /* Don't check lexeme for error */
    assert_token(&tokens[2], TOKEN_IDENTIFIER, "y", 1, 5);
    assert_token(&tokens[3], TOKEN_EOF, "", 1, 6);
    
    free_tokens(tokens, count);
    tests_passed++;
    printf("âœ… Test 16 PASSED\n\n");
}

/* Test 17: Error - Unterminated String */
void test_error_unterminated_string() {
    printf("Test 17: Error - Unterminated String\n");
    
    const char* source = "\"unclosed";
    int count;
    Token* tokens = tokenize(source, &count);
    
    assert(tokens != NULL);
    /* ERROR, EOF */
    assert(count == 2);
    
    assert_token(&tokens[0], TOKEN_ERROR, NULL, 1, 10);
    assert_token(&tokens[1], TOKEN_EOF, "", 1, 10);
    
    free_tokens(tokens, count);
    tests_passed++;
    printf("âœ… Test 17 PASSED\n\n");
}

/* Test 18: Full Program */
void test_full_program() {
    printf("Test 18: Full Program\n");
    
    const char* source = 
        "function main() as numeric\n"
        "  return 42\n"
        "end_function";
    
    int count;
    Token* tokens = tokenize(source, &count);
    
    assert(tokens != NULL);
    /* function, main, (, ), as, numeric, NEWLINE,
       return, 42, NEWLINE,
       end_function, EOF */
    assert(count == 12);
    
    assert_token(&tokens[0], TOKEN_FUNCTION, "function", 1, 1);
    assert_token(&tokens[1], TOKEN_IDENTIFIER, "main", 1, 10);
    assert_token(&tokens[2], TOKEN_LEFT_PAREN, "(", 1, 14);
    assert_token(&tokens[3], TOKEN_RIGHT_PAREN, ")", 1, 15);
    assert_token(&tokens[4], TOKEN_AS, "as", 1, 17);
    assert_token(&tokens[5], TOKEN_NUMERIC, "numeric", 1, 20);
    assert_token(&tokens[6], TOKEN_NEWLINE, "\n", 1, 27);
    assert_token(&tokens[7], TOKEN_RETURN, "return", 2, 3);
    assert_token(&tokens[8], TOKEN_NUMBER, "42", 2, 10);
    assert_token(&tokens[9], TOKEN_NEWLINE, "\n", 2, 12);
    assert_token(&tokens[10], TOKEN_END_FUNCTION, "end_function", 3, 1);
    assert_token(&tokens[11], TOKEN_EOF, "", 3, 13);
    
    free_tokens(tokens, count);
    tests_passed++;
    printf("âœ… Test 18 PASSED\n\n");
}

/* ============================================================================
 * MAIN TEST RUNNER
 * ============================================================================ */

int main() {
    printf("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘  MELP Stage 2 - Lexer Unit Tests                         â•‘\n");
    printf("â•‘  YZ_02 (Lexer Specialist)                                â•‘\n");
    printf("â•‘  Phase 2.0 - Task 2.4                                    â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");
    
    /* Run all tests */
    test_numbers();
    test_booleans();
    test_identifiers();
    test_function_keywords();
    test_control_flow_keywords();
    test_type_keywords();
    test_arithmetic_operators();
    test_comparison_operators();
    test_logical_operators();
    test_delimiters();
    test_complex_expression();
    test_function_declaration();
    test_multiline();
    test_comments();
    test_strings();
    test_error_invalid_character();
    test_error_unterminated_string();
    test_full_program();
    
    /* Summary */
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("TEST SUMMARY:\n");
    printf("  âœ… Passed: %d\n", tests_passed);
    printf("  âŒ Failed: %d\n", tests_failed);
    printf("  Total: %d\n", tests_passed + tests_failed);
    
    if (tests_failed == 0) {
        printf("\nğŸ‰ ALL TESTS PASSED! ğŸ‰\n");
        return 0;
    } else {
        printf("\nâš ï¸  SOME TESTS FAILED âš ï¸\n");
        return 1;
    }
}
