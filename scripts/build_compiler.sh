#!/bin/bash
# Build-time Concat Pipeline for MELP Self-hosting Compiler
# YZ_16 - 24 Aralık 2025

set -e  # Exit on error

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
STAGE1_DIR="$PROJECT_ROOT/compiler/stage1/modules"
BUILD_DIR="$PROJECT_ROOT/build"
TEMP_DIR="$BUILD_DIR/temp"

# Colors
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

echo -e "${BLUE}═══════════════════════════════════════════════════${NC}"
echo -e "${BLUE}  MELP Self-hosting Compiler - Build-time Concat ${NC}"
echo -e "${BLUE}═══════════════════════════════════════════════════${NC}"

# Create directories
mkdir -p "$BUILD_DIR"
mkdir -p "$TEMP_DIR"

# Define module order for concatenation
# Order matters: dependencies first
MODULES=(
    # Core types and tokens  
    "core/token_types.mlp"
    "core/token_utils.mlp"
    
    # Lexer (SADECE ana modüller, test dosyaları DEĞİL!)
    "lexer_mlp/char_utils.mlp"
    "lexer_mlp/tokenize_literals.mlp"
    "lexer_mlp/tokenize_operators.mlp"
    "lexer_mlp/tokenize_identifiers.mlp"
    "lexer_mlp/lexer.mlp"
    
    # Parser (AST)
    "parser_mlp/ast_nodes.mlp"
    "parser_mlp/token_stream.mlp"
    "parser_mlp/parser_errors.mlp"
    "parser_mlp/parser_expr.mlp"
    "parser_mlp/parser_stmt.mlp"
    "parser_mlp/parser_func.mlp"
    "parser_mlp/parser_struct.mlp"
    "parser_mlp/parser_enum.mlp"
    "parser_mlp/parser_control.mlp"
    "parser_mlp/parser_for.mlp"
    "parser_mlp/parser_call.mlp"
    "parser_mlp/parser_index.mlp"
    "parser_mlp/parser_import.mlp"
    "parser_mlp/parser.mlp"
    
    # Arrays (Parser + CodeGen)
    "arrays/arrays_parser.mlp"
    "arrays/arrays_codegen.mlp"
    
    # Code Generator
    "codegen_mlp/type_mapper.mlp"
    "codegen_mlp/symbol_table.mlp"
    "codegen_mlp/ir_builder.mlp"
    "codegen_mlp/codegen_literal.mlp"
    "codegen_mlp/codegen_variable.mlp"
    "codegen_mlp/codegen_arithmetic.mlp"
    "codegen_mlp/codegen_comparison.mlp"
    "codegen_mlp/codegen_logical.mlp"
    "codegen_mlp/codegen_while.mlp"
    "codegen_mlp/codegen_for.mlp"
    "codegen_mlp/codegen_control.mlp"
    "codegen_mlp/codegen_arrays.mlp"
    "codegen_mlp/codegen_functions.mlp"
    "codegen_mlp/codegen_stmt.mlp"
    "codegen_mlp/codegen_api.mlp"
)

OUTPUT_FILE="$TEMP_DIR/compiler_concat.mlp"

echo -e "${YELLOW}📦 Concatenating modules...${NC}"

# Start with a header comment
cat > "$OUTPUT_FILE" << 'EOF'
---
MELP Self-hosting Compiler (Build-time Concatenated)
Generated by: scripts/build_compiler.sh
Date: $(date '+%Y-%m-%d %H:%M:%S')

This file is automatically generated by concatenating modular source files.
DO NOT EDIT THIS FILE DIRECTLY - Edit source modules instead.
---

EOF

# Concatenate each module
for MODULE in "${MODULES[@]}"; do
    MODULE_PATH="$STAGE1_DIR/$MODULE"
    
    if [ ! -f "$MODULE_PATH" ]; then
        echo -e "${RED}❌ ERROR: Module not found: $MODULE${NC}"
        continue
    fi
    
    echo -e "  ${GREEN}✓${NC} $MODULE"
    
    # Add module separator comment
    echo "" >> "$OUTPUT_FILE"
    echo "-- ═══════════════════════════════════════════════════" >> "$OUTPUT_FILE"
    echo "-- MODULE: $MODULE" >> "$OUTPUT_FILE"
    echo "-- ═══════════════════════════════════════════════════" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
    
    # Append module content (skip import statements)
    grep -v "^import " "$MODULE_PATH" >> "$OUTPUT_FILE" || true
done

echo -e "${YELLOW}🔧 Removing duplicate function definitions...${NC}"

# Simple Python script to remove duplicate functions
cat > "$TEMP_DIR/remove_duplicates.py" << 'PYEOF'
import sys
import re

seen_functions = set()
seen_consts = set()
skip = False

for line in sys.stdin:
    # Skip duplicate const declarations
    if line.startswith('const '):
        m = re.match(r'const\s+\w+\s+([A-Z_][A-Z0-9_]*)', line)
        if m:
            const_name = m.group(1)
            if const_name in seen_consts:
                continue  # Skip duplicate const
            seen_consts.add(const_name)
    
    # Handle functions
    if line.startswith('function '):
        m = re.match(r'function\s+([a-zA-Z_][a-zA-Z0-9_]*)', line)
        if m:
            name = m.group(1)
            # Skip duplicate functions
            if name in seen_functions:
                skip = True
                continue
            # Skip main() functions (test functions, not needed in library)
            if name == 'main':
                skip = True
                continue
            seen_functions.add(name)
    
    if line.strip() == 'end_function':
        if skip:
            skip = False
            continue
    
    if not skip:
        sys.stdout.write(line)
PYEOF

cat "$OUTPUT_FILE" | python3 "$TEMP_DIR/remove_duplicates.py" > "$OUTPUT_FILE.tmp"
mv "$OUTPUT_FILE.tmp" "$OUTPUT_FILE"

echo -e "${GREEN}✅ Concatenation complete!${NC}"
echo -e "   Output: $OUTPUT_FILE"
echo -e "   Size: $(wc -l < "$OUTPUT_FILE") lines"

# Optional: Compile with Stage 0
if [ "$1" == "--compile" ]; then
    echo ""
    echo -e "${YELLOW}🔨 Compiling with Stage 0...${NC}"
    
    COMPILER="$PROJECT_ROOT/compiler/stage0/modules/functions/functions_compiler"
    OUTPUT_LL="$BUILD_DIR/compiler_gen1.ll"
    
    if [ ! -f "$COMPILER" ]; then
        echo -e "${RED}❌ ERROR: Stage 0 compiler not found: $COMPILER${NC}"
        exit 1
    fi
    
    if timeout 60 "$COMPILER" "$OUTPUT_FILE" "$OUTPUT_LL" 2>&1 | tee "$TEMP_DIR/compile.log"; then
        echo -e "${GREEN}✅ Compilation successful!${NC}"
        echo -e "   Output: $OUTPUT_LL"
    else
        echo -e "${RED}❌ Compilation failed! See: $TEMP_DIR/compile.log${NC}"
        exit 1
    fi
fi

echo ""
echo -e "${BLUE}═══════════════════════════════════════════════════${NC}"
echo -e "${GREEN}🎉 Build complete!${NC}"
echo -e "${BLUE}═══════════════════════════════════════════════════${NC}"
